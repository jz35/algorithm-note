# 第48课：二维前缀和、二维差分、离散化技巧

### 题目链接：https://www.luogu.com.cn/problem/P3397

### 题目链接：https://www.nowcoder.com/practice/50e1a93989df42efb0b1dec386fb4ccc

### 算法学习笔记：二维差分矩阵（1）

#### 题目描述

在一个 `n x n` 的矩阵上，执行多次区间更新操作。每次更新是在矩阵中指定的一个子矩阵上加上一个常数 `k`，最终要求输出更新后的矩阵。

#### 输入输出描述

- 输入：
  - 每次输入一个 `n`（矩阵大小）和 `q`（操作次数）。
  - 接下来输入 `q` 行，每行包含四个整数 `a, b, c, d`，表示将矩阵中从 `(a, b)` 到 `(c, d)` 的子矩阵所有元素加上 1。
- 输出：
  - 输出更新后的 `n x n` 矩阵，每行元素间以空格分隔。

#### 算法知识

二维差分矩阵是一种高效解决矩阵区间更新问题的算法。基本思想是将每个更新操作转换为在差分矩阵上的更新，从而避免直接操作矩阵中的每个元素。

1. **差分矩阵**：

   - 差分矩阵的核心思想是使用一个辅助矩阵，存储每个操作的“增量”，然后通过对差分矩阵进行前缀和的计算得到最终矩阵。
   - 对于一个二维矩阵的更新操作，可以通过在四个角上修改值来实现对一个子矩阵的增量更新。

2. **增量更新**：

   - 对于操作 

     ```
     (a, b)
     ```

      到 

     ```
     (c, d)
     ```

     ，我们可以通过四个边界位置的更新来实现：

     - `diff[a][b] += k`
     - `diff[c+1][b] -= k`
     - `diff[a][d+1] -= k`
     - `diff[c+1][d+1] += k`

3. **前缀和计算**：

   - 使用前缀和技术，将差分矩阵还原为实际的矩阵。通过遍历差分矩阵，并依次累加相邻的值，就能得到最终的矩阵。

4. **矩阵清空**：

   - 在进行多次操作时，需要在每次使用后清空差分矩阵，以防影响后续计算。

#### 代码实现

```cpp
#include <iostream>
#include <vector>

using namespace std;

class DiffMatrix {
private:
    int n, q;
    vector<vector<int>> diff;

public:
    // 初始化二维差分矩阵
    DiffMatrix(int size) : n(size), diff(size + 2, vector<int>(size + 2, 0)) {}

    // 差分矩阵更新操作：在 (a,b) 到 (c,d) 范围内加上 k
    void add(int a, int b, int c, int d, int k) {
        diff[a][b] += k;
        diff[c + 1][b] -= k;
        diff[a][d + 1] -= k;
        diff[c + 1][d + 1] += k;
    }

    // 计算前缀和，转换为真正的矩阵
    void build() {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];
            }
        }
    }

    // 清空矩阵，防止影响后续计算
    void clear() {
        for (int i = 1; i <= n + 1; i++) {
            for (int j = 1; j <= n + 1; j++) {
                diff[i][j] = 0;
            }
        }
    }

    // 输出矩阵
    void printResult() {
        for (int i = 1; i <= n; i++) {
            cout << diff[i][1];
            for (int j = 2; j <= n; j++) {
                cout << " " << diff[i][j];
            }
            cout << endl;
        }
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int n, q;
    while (cin >> n >> q) {
        DiffMatrix matrix(n);
        for (int i = 0, a, b, c, d; i < q; i++) {
            cin >> a >> b >> c >> d;
            matrix.add(a, b, c, d, 1);
        }
        matrix.build();
        matrix.printResult();
        matrix.clear();
    }

    return 0;
}
```

#### 代码解释

1. **初始化差分矩阵**：
   - 使用二维数组 `diff` 来存储差分矩阵，大小为 `(n + 2) x (n + 2)`，多加一行和一列用于边界处理。
2. **add 操作**：
   - `add(a, b, c, d, k)`：在差分矩阵中执行区间加法更新。通过修改四个边界值来完成对子矩阵 `(a, b)` 到 `(c, d)` 的更新。
3. **build 操作**：
   - `build()`：通过前缀和的方式将差分矩阵转换为实际矩阵，完成最终的矩阵计算。
4. **clear 操作**：
   - `clear()`：每次计算完成后，将差分矩阵重置为零，避免对下一次操作产生影响。
5. **printResult 操作**：
   - `printResult()`：输出最终的矩阵结果。

#### 时间和空间复杂度分析

- **时间复杂度**：
  - 每次 `add` 操作时间复杂度为 O(1)。
  - 每次 `build` 操作时间复杂度为 O(n^2)，因为需要遍历整个矩阵进行前缀和计算。
  - 每次 `printResult` 操作时间复杂度为 O(n^2)，因为需要输出整个矩阵。
  - 总体时间复杂度为 O(q + n^2)，其中 q 是操作次数，n 是矩阵的大小。
- **空间复杂度**：
  - 空间复杂度为 O(n^2)，用于存储差分矩阵。

#### 示例

输入：

```
3 2
1 1 2 2
2 2 3 3
```

输出：

```
1 1 0
1 2 1
0 1 1
```

#### 结论

二维差分矩阵通过差分技巧将区间更新的复杂度降为 O(1)，然后利用前缀和计算恢复出最终的矩阵。此方法在处理大规模矩阵更新时非常高效，适用于有多次区间更新的场景。         



### 算法学习笔记：二维差分矩阵（2）

#### 题目描述

在一个 `n x m` 的矩阵上，执行多个矩阵子区域更新操作。每次更新操作会在指定的子矩阵区域内增加一个常数 `k`。最终的目标是输出更新后的矩阵。

#### 输入输出描述

- **输入**：
  - 每次输入 `n`（矩阵的行数），`m`（矩阵的列数），和 `q`（操作次数）。
  - 接下来输入一个 `n x m` 的初始矩阵，每个位置 `i, j` 对应一个初始值。
  - 接着输入 `q` 行，每行包含 5 个整数 `a, b, c, d, k`，表示将矩阵中从 `(a, b)` 到 `(c, d)` 的子矩阵内所有元素加上 `k`。
- **输出**：
  - 输出更新后的 `n x m` 矩阵，每行元素之间以空格分隔。

#### 算法知识

1. **差分矩阵**：

   - **差分矩阵**是一种通过辅助矩阵存储“增量”来高效处理区间更新问题的算法。
   - 对于二维矩阵，通过差分矩阵的四个角进行增量更新，可以将二维区间更新的时间复杂度降为 `O(1)`。

2. **更新操作的实现**：

   - 每次更新操作 

     ```
     (a, b)
     ```

      到 

     ```
     (c, d)
     ```

     ，在差分矩阵上进行四个位置的增减：

     - `diff[a][b] += k`：在 `(a, b)` 位置加 `k`。
     - `diff[c+1][b] -= k`：在 `(c+1, b)` 位置减 `k`。
     - `diff[a][d+1] -= k`：在 `(a, d+1)` 位置减 `k`。
     - `diff[c+1][d+1] += k`：在 `(c+1, d+1)` 位置加 `k`。

   - 通过这四个增减操作，完成对指定子矩阵区域的更新。

3. **前缀和计算**：

   - 更新完成后，利用前缀和的方式将差分矩阵转换为实际的矩阵。
   - 通过遍历差分矩阵的每个元素，累加其左上、左、上三项，得到最终矩阵的每个值。

4. **矩阵清空**：

   - 每次计算完成后，需要清空差分矩阵，避免影响后续操作。

#### 代码实现

```cpp
#include <iostream>
#include <vector>
#include <cstdio>

using namespace std;

const int MAXN = 1005;
const int MAXM = 1005;

long diff[MAXN][MAXM];
int n, m, q;

void add(int a, int b, int c, int d, int k) {
    diff[a][b] += k;
    diff[c + 1][b] -= k;
    diff[a][d + 1] -= k;
    diff[c + 1][d + 1] += k;
}

void build() {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];
        }
    }
}

void clear() {
    for (int i = 1; i <= n + 1; i++) {
        for (int j = 1; j <= m + 1; j++) {
            diff[i][j] = 0;
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    while (cin >> n >> m >> q) {
        // 初始化矩阵
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                int val;
                cin >> val;
                add(i, j, i, j, val);
            }
        }

        // 处理区间更新
        for (int i = 1; i <= q; i++) {
            int a, b, c, d, k;
            cin >> a >> b >> c >> d >> k;
            add(a, b, c, d, k);
        }

        // 计算矩阵
        build();

        // 输出结果
        for (int i = 1; i <= n; i++) {
            cout << diff[i][1];
            for (int j = 2; j <= m; j++) {
                cout << " " << diff[i][j];
            }
            cout << "\n";
        }

        // 清空矩阵
        clear();
    }

    return 0;
}
```

#### 代码解释

1. **add函数**：
   - 处理区间更新操作。通过修改差分矩阵的四个角位置来表示对矩阵中子区域的增减。
2. **build函数**：
   - 利用前缀和的方式，将差分矩阵转换为实际矩阵。通过累加相邻的元素，得到最终的矩阵值。
3. **clear函数**：
   - 清空差分矩阵，为下一次计算做准备。
4. **主函数**：
   - 通过 `cin` 输入矩阵的尺寸 `n` 和 `m`，以及操作次数 `q`。
   - 对每次输入的初始矩阵进行差分操作。
   - 对每次的区间更新操作调用 `add` 函数。
   - 使用 `build` 函数计算最终的矩阵，输出结果。
   - 最后调用 `clear` 清空差分矩阵。

#### 时间和空间复杂度分析

- **时间复杂度**：
  - 对于每个区间更新，`add` 函数的时间复杂度为 `O(1)`。
  - `build` 函数的时间复杂度为 `O(n * m)`，因为需要遍历整个矩阵来计算前缀和。
  - 输出矩阵的时间复杂度为 `O(n * m)`。
  - 因此，总的时间复杂度为 `O(q + n * m)`，其中 `q` 是操作次数，`n` 和 `m` 是矩阵的行列数。
- **空间复杂度**：
  - 使用了一个大小为 `(n+1) x (m+1)` 的差分矩阵来存储增量信息，空间复杂度为 `O(n * m)`。

#### 示例

输入：

```
3 3 2
1 1 1
1 1 1
1 1 1
1 1 2 2 2
2 2 3 3 3
```

输出：

```
1 1 1
1 2 2
1 2 3
```

#### 总结

二维差分矩阵通过使用差分矩阵和前缀和技术，将区间更新的复杂度降到 `O(1)`，并通过前缀和的方式高效计算出最终矩阵。这种算法适用于多次区间更新的问题，能够显著提高效率。          