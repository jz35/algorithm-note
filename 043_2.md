# **第43课：根据数据量猜解法的技巧**

------

### **算法题：超级回文数**

#### **题目描述**

如果一个正整数自身是回文数，且它是一个回文数的平方，那么我们称这个数为超级回文数。给定两个正整数 L 和 R（以字符串形式表示），返回包含在范围 [L,R] 中的超级回文数的数目。

#### **输入描述**

输入包含两个字符串 L 和 R，表示范围 [1,1018) 内的整数。

- 1≤len(L)≤18
- 1≤len(R)≤18

#### **输出描述**

输出一个整数，表示在范围 [L,R] 内的超级回文数的数目。

#### **算法知识**

1. **回文数**：正读和反读都相同的数。
2. **超级回文数**：自身是回文数，且是某个回文数的平方。
3. **生成回文数**：通过种子数生成偶数长度和奇数长度的回文数。
4. **平方范围限制**：通过平方根限制搜索范围，避免溢出。
5. **回文数判断**：通过反转数字的方式判断一个数是否为回文数。

#### **题目链接**

[LeetCode - 超级回文数](https://leetcode.cn/problems/super-palindromes/)

------

### **算法思路**

1. **生成回文数**：
   - 使用种子数生成偶数长度和奇数长度的回文数。
   - 偶数长度：种子数反转后拼接到种子数后面。
   - 奇数长度：种子数去掉最后一位后反转，拼接到种子数后面。
2. **平方范围限制**：
   - 计算 [L,R] 的平方根范围，限制生成的回文数不超过平方根上限。
3. **判断超级回文数**：
   - 检查生成的回文数的平方是否在 [L,R] 范围内。
   - 检查平方值是否为回文数。
4. **优化**：
   - 使用种子数逐个生成回文数，避免暴力搜索。
   - 使用平方根限制范围，避免大数运算。



## c++实现：

```cpp
#include <string>
#include <cmath>
#include <limits>

using namespace std;

class Solution {
public:
    // 计算范围 [left, right] 内超级回文数的数量
    int superpalindromesInRange(string left, string right) {
        long long l = stoll(left);  // 将左边界字符串转化为数字
        long long r = stoll(right);  // 将右边界字符串转化为数字
        long long limit = static_cast<long long>(sqrt(r));  // 计算右边界的平方根
        long long seed = 1;  // 初始化种子
        long long num = 0;  // 当前的数字
        int ans = 0;  // 超级回文数的数量
        
        // 生成回文数并判断是否满足条件
        do {
            num = evenEnlarge(seed);  // 扩展生成偶数长度的回文数
            if (num <= limit && safeSquare(num) && check(num * num, l, r)) {
                ans++;
            }
            
            num = oddEnlarge(seed);  // 扩展生成奇数长度的回文数
            if (num <= limit && safeSquare(num) && check(num * num, l, r)) {
                ans++;
            }
            seed++;  // 增加种子，准备下一次生成回文数
        } while (num < limit);  // 直到超出 limit 为止
        
        return ans;  // 返回找到的超级回文数的数量
    }

private:
    // 判断一个数字是否可以安全地进行平方运算
    bool safeSquare(long long num) {
        return num <= static_cast<long long>(sqrt(numeric_limits<long long>::max()));  // 判断 num 是否小于 sqrt(max long long)
    }

    // 通过扩展种子生成一个偶数长度的回文数
    long long evenEnlarge(long long seed) {
        long long ans = seed;
        // 将种子数字反转并附加到原种子后面，生成偶数长度的回文数
        while (seed != 0) {
            ans = ans * 10 + seed % 10;
            seed /= 10;
        }
        return ans;  // 返回偶数长度回文数
    }

    // 通过扩展种子生成一个奇数长度的回文数
    long long oddEnlarge(long long seed) {
        long long ans = seed;
        seed /= 10;  // 移除最后一位数字
        // 将剩下的数字反转并附加到原种子后面，生成奇数长度的回文数
        while (seed != 0) {
            ans = ans * 10 + seed % 10;
            seed /= 10;
        }
        return ans;  // 返回奇数长度回文数
    }

    // 检查一个数字是否在范围内，并且是回文数
    bool check(long long ans, long long l, long long r) {
        return ans >= l && ans <= r && isPalindrome(ans);  // 检查是否在范围内，并且是回文数
    }

    // 判断一个数字是否是回文数
    bool isPalindrome(long long num) {
        long long offset = 1;
        // 计算数字的最高位数
        while (num / offset >= 10) {
            offset *= 10;
        }
        // 判断数字是否回文
        while (num != 0) {
            if (num / offset != num % 10) {
                return false;  // 如果最高位和最低位不相等，则不是回文
            }
            num = (num % offset) / 10;  // 去掉最高位和最低位
            offset /= 100;  // 调整偏移量
        }
        return true;  // 如果通过了所有检查，则是回文
    }
};
```

## 终极优化：

```c++
#include <string>
#include <vector>

using namespace std;

class Solution {
public:
    int superpalindromesInRange(string left, string right) {
        long long l = stoll(left);  // 将左边界字符串转化为数字
        long long r = stoll(right);  // 将右边界字符串转化为数字
        int i = 0;
        
        // 找到第一个大于等于 left 的超级回文数
        while (i < record.size() && record[i] < l) {
            i++;
        }
        
        int j = record.size() - 1;
        
        // 找到第一个小于等于 right 的超级回文数
        while (j >= 0 && record[j] > r) {
            j--;
        }
        
        // 计算 [left, right] 范围内的超级回文数的数量
        return (j >= i) ? (j - i + 1) : 0;
    }

private:
    // 存储已知的超级回文数
    const vector<long long> record = {
        1L, 4L, 9L, 121L, 484L, 10201L, 12321L, 14641L, 40804L, 44944L,
        1002001L, 1234321L, 4008004L, 100020001L, 102030201L, 104060401L,
        121242121L, 123454321L, 125686521L, 400080004L, 404090404L,
        10000200001L, 10221412201L, 12102420121L, 12345654321L,
        40000800004L, 1000002000001L, 1002003002001L, 1004006004001L,
        1020304030201L, 1022325232201L, 1024348434201L, 1210024200121L,
        1212225222121L, 1214428244121L, 1232346432321L, 1234567654321L,
        4000008000004L, 4004009004004L, 100000020000001L, 100220141022001L,
        102012040210201L, 102234363432201L, 121000242000121L,
        121242363242121L, 123212464212321L, 123456787654321L,
        400000080000004L, 10000000200000001L, 10002000300020001L,
        10004000600040001L, 10020210401202001L, 10022212521222001L,
        10024214841242001L, 10201020402010201L, 10203040504030201L,
        10205060806050201L, 10221432623412201L, 10223454745432201L,
        12100002420000121L, 12102202520220121L, 12104402820440121L,
        12122232623222121L, 12124434743442121L, 12321024642012321L,
        12323244744232321L, 12343456865434321L, 12345678987654321L,
        40000000800000004L, 40004000900040004L, 1000000002000000001L,
        1000220014100220001L, 1002003004003002001L, 1002223236323222001L,
        1020100204020010201L, 1020322416142230201L, 1022123226223212201L,
        1022345658565432201L, 1210000024200000121L, 1210242036302420121L,
        1212203226223022121L, 1212445458545442121L, 1232100246420012321L,
        1232344458544432321L, 1234323468643234321L, 4000000008000000004L
    };
};
```



### 主要功能与步骤：

1. **`superpalindromesInRange`**：这个方法计算给定区间 `[left, right]` 中的超级回文数的数量。通过生成偶数和奇数长度的回文数，并检查每个回文数的平方是否仍然是回文数，并且在给定范围内。
2. **`safeSquare`**：判断数字是否能安全地平方。这里检查数字是否小于 `sqrt(max long long)`，避免溢出。
3. **`evenEnlarge` 和 `oddEnlarge`**：这两个方法分别生成偶数和奇数长度的回文数。通过反转种子数字并附加到原种子后面来生成回文数。
4. **`check`**：检查生成的回文数的平方是否满足在给定范围内，并且是否是回文数。
5. **`isPalindrome`**：判断一个数字是否是回文数。通过比较数字的高位和低位，逐步向内逼近。

### 运行流程：

1. 将左边界和右边界转换为数字。
2. 计算右边界的平方根，并使用种子生成偶数和奇数长度的回文数。
3. 对于每个回文数，判断其平方是否也是回文数，并且在给定范围内。
4. 返回符合条件的超级回文数的数量。

通过上述步骤，能够有效地计算给定范围内的超级回文数。

