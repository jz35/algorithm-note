# 第50课：双指针技巧及相关题目

### **算法笔记：寻找重复数**

#### **题目描述：**

给定一个包含 `n + 1` 个整数的数组 `nums`，其中每个整数都在 `[1, n]` 范围内（包括 `1` 和 `n`）。我们知道至少存在一个重复的整数。请设计一个算法，要求 **不修改** 数组且只用常量级 `O(1)` 的额外空间，找出这个重复的整数。

#### **核心思路：**

该问题可以通过 **快慢指针（Floyd's Tortoise and Hare）** 方法来解决。利用数组中的元素值作为指针，快指针每次移动两步，慢指针每次移动一步。最终快慢指针将在环内相遇，而相遇的点即为重复的数字。

#### **解题步骤：**

1. **快慢指针的定义：**
   - **快指针（Fast Pointer）**：每次移动两步。
   - **慢指针（Slow Pointer）**：每次移动一步。
2. **初始化：** 快指针初始化为 `nums[0]`，慢指针初始化为 `nums[nums[0]]`。这是因为我们可以将数组视为一个链表，数组中的每个数字都指向下一个索引。
3. **第一次相遇：**
   - 快慢指针同时移动，当它们相遇时，说明它们已经进入了环（重复数字的位置）。此时，我们将快指针回到数组的起始位置，慢指针保持不动。
4. **第二次相遇（找到环的入口）：**
   - 重新将快指针指向数组起始位置，然后快慢指针同时以相同速度移动。再次相遇时，指针相遇的位置即为环的入口，即重复数字的位置。

#### **代码实现：**

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        // 判断输入的数组是否有效
        if (nums.empty() || nums.size() < 2) {
            return -1;
        }
        
        // 初始化慢指针和快指针
        int slow = nums[0];
        int fast = nums[nums[0]];
        
        // 使用快慢指针检测环的相遇点
        while (slow != fast) {
            slow = nums[slow]; // 慢指针每次移动一步
            fast = nums[nums[fast]]; // 快指针每次移动两步
        }
        
        // 相遇后，快指针回到头部
        fast = 0;
        
        // 找到环的入口点，即重复的数字
        while (slow != fast) {
            slow = nums[slow]; // 慢指针每次移动一步
            fast = nums[fast]; // 快指针每次移动一步
        }
        
        return slow; // 返回重复的数字
    }
};

```

#### **算法的正确性分析：**

1. **快慢指针相遇：** 快指针每次移动两步，慢指针每次移动一步。当快指针进入环后，它会绕环移动，慢指针则直接进入环。最终两者将在环内某一位置相遇。
2. **环的入口：** 在相遇后，快指针被重新指向数组的起始位置，慢指针保持在相遇的位置。快慢指针同时以相同速度前进，直到再次相遇。相遇的点即为环的入口，而环的入口即为重复数字。
3. **空间复杂度：** 本算法没有使用额外的数组或哈希表来存储状态，因此空间复杂度为 `O(1)`。
4. **时间复杂度：** 快慢指针只会遍历数组的每一位置最多两次，因此时间复杂度为 `O(n)`，其中 `n` 是数组的长度。

#### **数学证明（环的入口）：**

1. **环的结构：**
   - 假设环的入口到数组起始位置的距离为 `C`。
   - 假设环的长度为 `R`。
2. **快慢指针相遇时的状态：**
   - 快指针已进入环，慢指针在环内，假设它们相遇时的距离为 `D_s`（慢指针的距离）。
   - 快指针移动的距离是慢指针的两倍：`D_f = 2 * D_s`。
3. **相遇后，重新回到起始位置：**
   - 重新将快指针指向数组的起始位置，慢指针保持不动。
   - 快慢指针同步移动，经过 `C` 步后相遇，再次相遇时，指针位置即为环的入口。

#### **总结：**

- **核心思想**：利用快慢指针的方法，快速定位环的入口，即重复的数字。
- **时间复杂度**：`O(n)`，其中 `n` 是数组的长度。
- **空间复杂度**：`O(1)`，只使用了常数额外空间。
- **算法的正确性**：通过数学证明和快慢指针的性质保证了算法的正确性。

通过上述步骤和分析，能够准确找到重复的数字，并且满足题目中的空间复杂度要求。