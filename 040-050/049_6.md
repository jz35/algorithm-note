# 第49课：滑动窗口技巧和相关题目

### **题目描述：**

给定一个正整数数组 `nums` 和一个整数 `k`，返回 `nums` 中不同整数的个数恰好为 `k` 的子数组的数量。子数组是数组的连续部分。

### **输入描述：**

- 一个长度为 `n` 的数组 `nums`。
- 一个整数 `k`，表示子数组中不同整数的个数。

### **输出描述：**

- 返回符合条件的子数组数量，即不同整数个数恰好为 `k` 的子数组的数量。

### **算法知识：**

这道题的关键是利用滑动窗口（双指针方法）来动态调整窗口大小，统计当前窗口中包含的不同整数的个数。使用滑动窗口的核心思想是通过移动左右指针来维护一个有效的子数组范围，同时在每次扩展或收缩窗口时，计算当前子数组的数量。

#### **思路：**

1. **计算不同整数个数不超过 `k` 的子数组数：**
   - 利用滑动窗口的左边界 `l` 和右边界 `r` 来维持当前子数组范围 `[l, r]`。
   - 使用 `cnts` 数组记录当前窗口中每个元素的出现次数，`collect` 用于记录窗口中不同整数的数量。
   - 每次右边界扩展时，增加窗口内的子数组数量。
   - 当窗口内的不同整数数量超过 `k` 时，收缩左边界，直到窗口内的不同整数数量不超过 `k`。
2. **通过差值得到恰好 `k` 个不同整数的子数组数：**
   - 计算不同整数个数不超过 `k` 的子数组数量 `numsOfMostKinds(nums, k)` 和不同整数个数不超过 `k-1` 的子数组数量 `numsOfMostKinds(nums, k-1)`。
   - 二者相减，得到正好有 `k` 个不同整数的子数组数量：
      `numsOfMostKinds(nums, k) - numsOfMostKinds(nums, k-1)`。

#### **代码实现：**

```cpp
class Solution {
public:
    int subarraysWithKDistinct(vector<int>& nums, int k) {
        return numsOfMostKinds(nums, k) - numsOfMostKinds(nums, k - 1);
    }

private:
    // 计算nums中有多少个子数组，其中不同整数的个数不超过k
    int numsOfMostKinds(const vector<int>& arr, int k) {
        vector<int> cnts(20001, 0); // 计数数组，假设数组元素在 1~20000 范围内
        int n = arr.size();
        int ans = 0;
        int collect = 0; // 记录当前窗口中不同整数的个数
        int l = 0, r = 0;

        // 遍历整个数组，r为窗口的右边界，l为窗口的左边界
        while (r < n) {
            // 扩展窗口
            if (++cnts[arr[r]] == 1) {
                collect++; // 如果arr[r]是第一次出现，收集一个新元素
            }

            // 当不同元素的数量超过k时，收缩窗口
            while (collect > k) {
                if (--cnts[arr[l++]] == 0) {
                    collect--; // 如果某个元素完全移出窗口，减少收集的不同元素个数
                }
            }

            // 统计以r为结尾的所有符合条件的子数组数
            ans += r - l + 1;

            // 扩展右边界
            r++;
        }
        return ans;
    }
};
```

#### **代码解释：**

1. **`subarraysWithKDistinct`**：
   - 该函数通过调用 `numsOfMostKinds` 函数来计算两个数值的差值，得到正好包含 `k` 个不同整数的子数组数量。
   - `numsOfMostKinds(nums, k)` 计算不同整数个数不超过 `k` 的子数组数目，`numsOfMostKinds(nums, k-1)` 计算不同整数个数不超过 `k-1` 的子数组数目。二者相减得到正好有 `k` 个不同整数的子数组数量。
2. **`numsOfMostKinds`**：
   - 用滑动窗口方法计算不同整数个数不超过 `k` 的子数组数量。
   - 通过维护窗口内不同整数个数 `collect`，动态调整窗口的左右边界，并通过计数每次窗口扩展时，符合条件的子数组数。
3. **时间复杂度**：
   - 时间复杂度为 `O(n)`，其中 `n` 是数组的长度。每个元素最多会被左指针和右指针访问一次。

#### **总结：**

- **滑动窗口** 是解决这类区间内计算问题的有效方法，尤其是在需要动态调整区间大小时。
- 通过利用滑动窗口的左边界和右边界，可以高效地计算数组中符合条件的子数组数量。
- 此题通过差值法巧妙地计算出不同整数个数恰好为 `k` 的子数组数量。

