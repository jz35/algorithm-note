# 第49课：滑动窗口技巧和相关题目

### 题目：累加和大于等于 `target` 的最短子数组长度

#### 题目描述：

给定一个包含 `n` 个正整数的数组 `nums` 和一个正整数 `target`，请你找出累加和大于等于 `target` 的最短子数组的长度。如果没有符合条件的子数组，返回 `0`。

#### 输入：

- 一个整数 `target`，表示累加和的目标值。
- 一个整数数组 `nums`，表示正整数数组。

#### 输出：

- 返回最短子数组的长度。如果没有符合条件的子数组，返回 `0`。

#### 示例：

**示例 1**：

```plaintext
输入: target = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是最小的符合条件的子数组，它的和 >= 7。
```

**示例 2**：

```plaintext
输入: target = 4, nums = [1,4,4]
输出: 1
解释: 子数组 [4] 是最小的符合条件的子数组，它的和 >= 4。
```

**示例 3**：

```plaintext
输入: target = 11, nums = [1,1,1,1,1,1,1,1]
输出: 0
解释: 没有符合条件的子数组。
```

#### 解法思路：

1. **滑动窗口（Two-pointer / 双指针）**：
   - 使用滑动窗口来解题。我们维护一个动态变化的窗口，其元素和为 `sum`，并且尝试最小化满足条件的窗口大小。
   - 扩展窗口：右指针（`r`）向右移动，增加窗口的元素。
   - 收缩窗口：当窗口的累加和 `sum` 大于等于 `target` 时，尝试移动左指针（`l`）收缩窗口，直到窗口和再次小于 `target`。
2. **核心操作**：
   - 在每次窗口的和大于等于 `target` 时，记录窗口的大小，并且更新最小窗口长度。
   - 通过维护一个最小的长度来确保我们得到符合条件的最小子数组。

#### 代码：

```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        // 初始化最小长度为一个很大的值
        int ans = INT_MAX;
        // 滑动窗口的左边界l和右边界r，sum是当前窗口的和
        for (int l = 0, r = 0, sum = 0; r < nums.size(); r++) {
            // 扩展窗口，将nums[r]加入到sum中
            sum += nums[r];
            
            // 当窗口的和大于等于目标值时，尝试收缩左边界
            while (sum - nums[l] >= target) {
                // 如果左边界的元素可以移出并且不影响达到目标，移出左边界元素
                sum -= nums[l++];
            }
            
            // 检查当前窗口是否满足条件，更新最小长度
            if (sum >= target) {
                ans = min(ans, r - l + 1);
            }
        }
        
        // 如果没有找到符合条件的子数组，返回0，否则返回最小长度
        return ans == INT_MAX ? 0 : ans;
    }
};
```

#### 时间复杂度：

- 时间复杂度为 O(n)，其中 n 为数组 `nums` 的长度。右指针 `r` 和左指针 `l` 最多各遍历一次数组，因此整体时间复杂度是 O(n)。

#### 空间复杂度：

- 空间复杂度为 O(1)，只使用了常数空间用于存储窗口的累加和和最小子数组长度。

#### 题目链接：

https://leetcode.cn/problems/minimum-size-subarray-sum/

------

### 总结：

- **题目类型**：滑动窗口、双指针
- **难度**：中等
- **常见应用**：此类题目常常用来解决“最小窗口长度”、“最大/最小子数组”等问题，通过双指针技术高效地查找最优解。