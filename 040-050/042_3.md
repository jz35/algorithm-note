# **第42课：对数器打表找规律的技巧**

### 1.算法题：

- 判断一个数字是否可以表示为若干个（数量 > 1）连续正整数的和。

### 2.C++ 代码:

```cpp
#include <iostream>
using namespace std;

// 方法1：暴力方法，尝试每个起始点，检查是否可以表示为连续整数的和
bool is1(int num) {
    // 从1开始，逐步增加起始点
    for (int start = 1, sum; start <= num; start++) {
        sum = start;
        // 对每个起始点，检查是否能找到一个连续的正整数序列使得和等于num
        for (int j = start + 1; j <= num; j++) {
            if (sum + j > num) {
                break;  // 如果和超过了num，跳出内层循环
            }
            if (sum + j == num) {
                return true;  // 找到一个连续和等于num的情况，返回true
            }
            sum += j;  // 否则继续增加sum
        }
    }
    return false;  // 如果找不到，返回false
}

// 方法2：利用数学性质，如果数字是2的幂，不能表示为连续和
bool is2(int num) {
    // 如果num是2的幂，返回false，否则返回true
    return (num & (num - 1)) != 0;
}

int main() {
    // 测试1到200的每个数字是否可以表示为连续整数的和
    for (int num = 1; num < 200; num++) {
        cout << num << " : " << (is1(num) ? "T" : "F") << endl;
    }
    return 0;
}
```

### 3. 解释

#### 方法1：暴力方法（`is1`）

- 通过两个嵌套循环，外层循环逐步尝试每一个可能的起始数字 `start`，内层循环逐步增加数字，从 `start + 1` 开始，加到和 `sum`。
- 每次内层循环都会累加当前数字到 `sum`，直到 `sum` 超过 `num` 或等于 `num`，如果等于，则说明找到了一个符合条件的连续正整数序列，返回 `true`。
- 如果没有找到，则返回 `false`。

#### 方法2：数学优化（`is2`）

- 如果一个数字是 2 的幂（例如 1, 2, 4, 8, 16 等），它不能被表示为若干个连续的正整数的和。
- 通过判断数字 `num` 是否为 2 的幂来优化判断。使用位运算 `num & (num - 1)` 可以检测一个数字是否是 2 的幂，如果是，结果为 0，返回 `false`。

#### 时间复杂度：

- **方法1**：时间复杂度为 `O(n^2)`，因为对每一个 `start`，需要检查每个后续的数直到 `num`。
- **方法2**：时间复杂度为 `O(1)`，通过位运算快速判断数字是否为 2 的幂。

#### 输出：

- 程序会打印 1 到 199 中每个数字是否可以表示为若干个连续正整数的和，`T` 代表可以，`F` 代表不可以。

### 结论：

- **方法1**：暴力解法，适用于小规模数据。
- **方法2**：通过数学性质优化，效率高，适合大规模数据。