# 第50课：双指针技巧及相关题目

------

### **题目描述：**

给定一个非负整数数组 `nums`。`nums` 中一半整数是奇数，一半整数是偶数。
 对数组进行排序，使得当 `nums[i]` 为奇数时，`i` 也是奇数；当 `nums[i]` 为偶数时，`i` 也是偶数。
 你可以返回任何满足上述条件的数组作为答案。

### **输入描述：**

- 一个包含偶数和奇数的整数数组 `nums`，长度为 `n`，且 `n` 为偶数。

### **输出描述：**

- 一个排序后的数组 `nums`，使得奇数和偶数分别出现在奇数下标和偶数下标。

### **算法知识：**

此问题可以通过双指针技术来解决：

1. **奇数和偶数的分配：**
   - 使用两个指针 `odd` 和 `even`，分别指向数组中的奇数和偶数应在的位置。
   - `odd` 用于指向奇数下标，`even` 用于指向偶数下标。
2. **交换策略：**
   - 遍历数组，对于每个元素：
     - 如果元素是奇数并且它不在奇数下标位置（即不是奇数下标），则与下一个正确的奇数下标的元素交换。
     - 如果元素是偶数并且它不在偶数下标位置，则与下一个正确的偶数下标的元素交换。
3. **时间复杂度：**
   - 由于我们只需要遍历数组一次，每个元素最多交换一次，所以时间复杂度为 `O(n)`，其中 `n` 为数组的长度。
4. **空间复杂度：**
   - 该算法仅使用了常数额外空间，因此空间复杂度为 `O(1)`。

### **代码实现：**

```cpp
class Solution {
public:
    vector<int> sortArrayByParityII(vector<int>& nums) {
        int n = nums.size();
        for (int odd = 1, even = 0; odd < n && even < n;) {
            if ((nums[n - 1] & 1) == 1) {  // 如果最后一个元素是奇数
                swap(nums[odd], nums[n - 1]);  // 交换奇数元素
                odd += 2;  // 奇数下标向后移
            } else {
                swap(nums[even], nums[n - 1]);  // 如果是偶数，交换偶数元素
                even += 2;  // 偶数下标向后移
            }
        }
        return nums;
    }
};
```

### **代码解释：**

- **双指针策略：** 使用两个指针 `odd` 和 `even`，分别负责处理奇数和偶数的位置。
- **交换操作：** 在遍历数组时，判断元素是否符合条件，如果不符合则交换并移动指针。
- **结束条件：** 当遍历结束时，数组已经满足奇偶排序的条件。

### **复杂度分析：**

- **时间复杂度：** `O(n)`，数组遍历一次，且每个元素最多交换一次。
- **空间复杂度：** `O(1)`，没有使用额外的空间。

### **测试链接：**

[LeetCode  - Sort Array by Parity II](https://leetcode.cn/problems/sort-array-by-parity-ii/)

