# 第50课：双指针技巧及相关题目

### 算法题：盛最多水的容器

#### 题目描述

给定一个长度为 `n` 的整数数组 `height`，数组中的每个元素 `height[i]` 代表一个柱子的高度。柱子的位置与坐标 `(i, 0)` 和 `(i, height[i])` 之间的线段相连。选择两条柱子，求这两条柱子与 `x` 轴共同构成的容器，能够容纳的最多水量。

要求：

- 返回容器能够储存的最大水量。
- 容器的水量由两个柱子的高度和它们之间的距离决定，且容器的宽度为两个柱子之间的距离。

#### 示例

**输入：**

```plaintext
height = [1,8,6,2,5,4,8,3,7]
```

**输出：**

```plaintext
49
```

**解释：** 容器的最大水量由柱子 `height[1]` 和 `height[8]` 构成，水量为 `min(8, 7) * (8 - 1) = 49`。

#### 思路

1. **双指针法**：
    使用两个指针 `l` 和 `r`，分别指向数组的起始位置和末尾位置。
2. **计算水量**：
    对于每一对柱子，水量的计算公式是：
    `water = min(height[l], height[r]) * (r - l)`
    其中 `min(height[l], height[r])` 是这两根柱子中较短的那一根，`(r - l)` 是它们之间的宽度。
3. **更新指针**：
    每次计算完水量后，判断较短的柱子所在的位置，并移动指针。
   - 如果 `height[l] <= height[r]`，则 `l++`；
   - 否则，`r--`。
4. **终止条件**：
    当 `l` 和 `r` 相遇时，结束循环。

#### 代码实现

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int ans = 0;
        int l = 0, r = height.size() - 1;
        
        while (l < r) {
            ans = max(ans, min(height[l], height[r]) * (r - l));
            if (height[l] <= height[r]) {
                l++;
            } else {
                r--;
            }
        }
        
        return ans;
    }
};
```

#### 复杂度分析

- **时间复杂度**：`O(n)`
   只需要一次遍历数组，双指针移动一次即可。
- **空间复杂度**：`O(1)`
   使用常数空间，只有少数几个变量用于存储结果和指针。

#### 关键点总结

- 使用双指针法解决问题，通过每次选择较短的柱子，尽量扩大宽度，从而最大化容器的水量。
- 在每次计算时更新水量，并通过移动指针优化解法。