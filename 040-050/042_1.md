# **第42课：对数器打表找规律的技巧**

## 算法题：

- 给定一个袋子可以装 8 个苹果，另一个袋子可以装 6 个苹果，要求确保每个袋子都装满。
- 如果 `n` 个苹果，问至少需要多少个袋子。如果不存在满足条件的方案，返回 -1。

## C++ 代码:

下面是将该算法转换为 C++ 代码：

```cpp
#include <iostream>
#include <algorithm>
using namespace std;

// 递归求解，返回最少需要多少个袋子
int bags1(int apple) {
    int ans = f(apple);
    return ans == INT_MAX ? -1 : ans;  // 如果无法装满所有袋子，返回-1
}

// 当前剩余rest个苹果，返回至少需要多少袋子
int f(int rest) {
    if (rest < 0) {  // 如果剩余苹果数为负，返回无效解
        return INT_MAX;
    }
    if (rest == 0) {  // 如果剩余苹果数为零，不需要更多袋子
        return 0;
    }
    // 使用8个苹果的袋子，递归计算剩余的苹果
    int p1 = f(rest - 8);
    // 使用6个苹果的袋子，递归计算剩余的苹果
    int p2 = f(rest - 6);

    // 如果存在有效解，增加袋子的数量
    p1 += p1 != INT_MAX ? 1 : 0;
    p2 += p2 != INT_MAX ? 1 : 0;

    // 返回最少袋子数
    return min(p1, p2);
}

// 使用数学方法优化的实现
int bags2(int apple) {
    if (apple % 2 != 0) {  // 如果苹果数为奇数，不可能装满袋子，直接返回-1
        return -1;
    }
    // 针对小于18个苹果的特殊情况
    if (apple < 18) {
        if (apple == 0) {  // 如果没有苹果，袋子数为0
            return 0;
        }
        if (apple == 6 || apple == 8) {  // 6个苹果或8个苹果，1个袋子即可
            return 1;
        }
        if (apple == 12 || apple == 14 || apple == 16) {  // 特定数量的苹果需要2个袋子
            return 2;
        }
        return -1;  // 其他无法组合的情况返回-1
    }
    // 对于18个及以上的苹果，使用数学公式计算
    return (apple - 18) / 8 + 3;  // 用 8 个苹果装袋，至少需要3个袋子
}

int main() {
    // 测试 bags1 方法，输出每个数量的苹果所需袋子数
    for (int apple = 0; apple < 100; apple++) {
        cout << apple << " : " << bags1(apple) << endl;
    }
    return 0;
}
```

### 解释：

1. **bags1 方法**：
   - 该方法是通过递归的方式求解剩余苹果的最小袋子数。
   - 如果剩余苹果数为负，返回一个大的值（`INT_MAX`），表示无法满足。
   - 如果剩余苹果数为 0，表示苹果正好用完，返回 0。
   - 递归调用 `f(rest - 8)` 和 `f(rest - 6)`，分别尝试使用 8 个和 6 个苹果的袋子。
   - 最后返回最小的袋子数。
2. **bags2 方法**：
   - 该方法是通过数学分析来简化问题。
   - 如果苹果数为奇数，返回 -1，因为无法用 6 和 8 个苹果的袋子装满奇数个苹果。
   - 对于小于 18 个苹果的特殊情况，通过直接判断 6, 8, 12, 14, 16 等情况来返回结果。
   - 对于 18 个及以上的苹果，使用数学公式 `(apple - 18) / 8 + 3` 来计算。

### 复杂度分析：

- **bags1** 的时间复杂度：递归深度最大为 `apple / 6`，每次递归有两个选择（使用 8 个袋子或 6 个袋子），因此最坏情况下时间复杂度为 `O(2^n)`，不太适合大规模输入。
- **bags2** 的时间复杂度： `O(1)`，是优化后的方法，直接通过数学公式计算。

### 总结：

- **bags1** 使用了递归，虽然简洁但效率较低，适合较小的输入。
- **bags2** 通过数学优化，时间复杂度为常数，适用于大范围的输入。