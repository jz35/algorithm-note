# **第42课：对数器打表找规律的技巧**

### 算法题：

- 给定一个总草的重量 `n`，两只牛轮流吃草，A 牛先吃，B 牛后吃。
- 每只牛在自己的回合中，必须吃掉的草的重量是 4 的幂（即 1、4、16、64...）。
- 谁在自己的回合将草吃完，谁就获胜。根据输入的 `n`，返回谁赢。

### C++ 代码

以下是转换后的 C++ 代码：

```cpp
#include <iostream>
#include <string>
using namespace std;

// 递归方法计算谁会赢
string win1(int n) {
    return f(n, "A");
}

// 递归函数，判断当前回合的选手cur是否能够最终获胜
string f(int rest, string cur) {
    // 计算对手是谁
    string enemy = (cur == "A") ? "B" : "A";
    
    // 如果剩余的草少于5，判断直接结果
    if (rest < 5) {
        return (rest == 0 || rest == 2) ? enemy : cur;
    }
    
    // 否则开始判断每个 4 的幂次选择
    int pick = 1;
    while (pick <= rest) {
        // 如果选择吃掉草后，对手会输，则当前选手获胜
        if (f(rest - pick, enemy) == cur) {
            return cur;
        }
        pick *= 4;  // 增加选择的草的量（4 的幂）
    }
    // 如果没有获胜的分支，说明对手获胜
    return enemy;
}

// 数学推导方法优化
string win2(int n) {
    // 根据数学推导，B 赢的情况为 n % 5 == 0 或 n % 5 == 2
    if (n % 5 == 0 || n % 5 == 2) {
        return "B";
    } else {
        return "A";
    }
}

int main() {
    // 测试所有从0到50的情况
    for (int i = 0; i <= 50; i++) {
        cout << i << " : " << win1(i) << endl;
    }
    return 0;
}
```

### 解释：

1. **递归方法 `win1`**：
   - 使用递归的方式判断在剩余草量 `n` 的情况下，先手选手 A 是否能赢。每次递归都尝试选择吃掉 1、4、16、64... 这些草的数量，并交替进行递归计算。
2. **递归函数 `f`**：
   - `f` 是一个递归函数，它接受当前剩余的草量 `rest` 和当前轮到的选手 `cur`（A 或 B）。递归基准条件是：当剩余草量小于 5 时，可以直接判断胜负。
   - 如果当前选手能够通过吃掉草的量使得对手最终无法获胜，则返回当前选手获胜。
3. **优化方法 `win2`**：
   - 通过数学推导，可以简化问题。观察到如果剩余草量 `n` 对 5 取模的结果是 `0` 或 `2` 时，B 牛会赢，否则 A 牛会赢。
4. **复杂度分析**：
   - **递归方法**的时间复杂度为 `O(4^n)`，因为每次递归会有 4 个选择（1, 4, 16, 64），所以复杂度较高，适合较小的输入。
   - **优化方法**的时间复杂度为 `O(1)`，直接通过数学公式判断，非常高效。

### 总结：

- **递归方法**：简单但效率较低，适用于小规模数据。
- **数学优化方法**：通过模运算简化了问题，效率非常高，适合大规模数据。