# 算法第38课：常见经典递归过程解析

#### 前置知识

- **相关讲解**：在学习本节内容前，建议先熟悉讲解017、020、021、023、036、037等章节，这些章节都对递归进行了分析。
- **递归类型**：递归分为带路径的递归和不带路径的递归。大部分动态规划（dp）和状态压缩dp可以认为是路径简化了结构，后续在dp专题中会详细讲述。需要注意的是，任何递归都可以看作是深度优先搜索（dfs），且非常灵活，回溯这个术语并不重要。

#### 经典递归题目解析

##### 题目1：返回字符串全部子序列，子序列要求去重

- **问题描述**：给定一个字符串，返回其所有不重复的子序列。
- **时间复杂度**：O(2^n * n)，其中n为字符串的长度。
- **思路**：可以通过递归的方式，对于字符串中的每个字符，选择包含或不包含该字符，从而生成所有可能的子序列，并在过程中去重。

##### 题目2：返回数组的所有组合，可以无视元素顺序

- **问题描述**：给定一个数组，返回其所有可能的组合，组合中元素的顺序可以忽略。
- **时间复杂度**：O(2^n * n)，其中n为数组的长度。
- **思路**：同样采用递归方法，从数组的第一个元素开始，依次选择包含或不包含当前元素，递归生成所有组合。

##### 题目3：返回没有重复值数组的全部排列

- **问题描述**：给定一个没有重复值的数组，返回其所有可能的排列。
- **时间复杂度**：O(n! * n)，其中n为数组的长度。
- **思路**：使用递归实现排列生成。在每一步中，选择一个未被使用的元素作为当前排列的一部分，然后对剩余元素递归生成排列，直到所有元素都被使用。

##### 题目4：返回可能有重复值数组的全部排列，排列要求去重

- **问题描述**：给定一个可能包含重复值的数组，返回其所有不重复的排列。
- **时间复杂度**：O(n! * n)，其中n为数组的长度。
- **思路**：在生成排列的过程中，需要增加去重的逻辑。可以在递归前对数组进行排序，然后在选择元素时，跳过与前一个相同且前一个未被使用的元素，从而避免生成重复的排列。

##### 题目5：用递归逆序一个栈

- **问题描述**：给定一个栈，使用递归方法将其逆序。
- **时间复杂度**：O(n^2)，其中n为栈的大小。
- **思路**：递归地将栈顶元素取出，然后对剩余的栈继续逆序操作，最后将取出的元素压入栈底，实现逆序。

##### 题目6：用递归排序一个栈

- **问题描述**：给定一个栈，使用递归方法将其排序。
- **时间复杂度**：O(n^2)，其中n为栈的大小。
- **思路**：递归地将栈顶元素取出，对剩余的栈进行排序，然后将取出的元素插入到已排序栈的合适位置，实现整个栈的排序。

##### 题目7：打印n层汉诺塔问题的最优移动轨迹

- **问题描述**：给定n层汉诺塔，打印出将其从一个柱子移动到另一个柱子的最优移动轨迹。
- **时间复杂度**：O(2^n)，其中n为汉诺塔的层数。
- **思路**：递归地将n-1个盘子从起始柱子移动到辅助柱子，然后将最大的盘子移动到目标柱子，最后再将n-1个盘子从辅助柱子移动到目标柱子，从而实现整个汉诺塔的移动。

### 总结

递归是一种强大的算法思想，通过将问题分解为更小的子问题来解决。在解决递归问题时，需要明确递归的终止条件和递归关系，并注意去重、排序等细节问题。通过以上经典题目的练习，可以加深对递归的理解和应用能力。