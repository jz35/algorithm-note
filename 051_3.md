# 第51课：二分答案法及相关题目

### **题目描述：**

机器人正在玩一个古老的基于 DOS 的游戏。游戏中有 N+1N+1 座建筑，从 00 到 NN 依次编号，并从左到右排列。
 编号为 00 的建筑高度为 00，编号为 ii 的建筑的高度为 H(i)H(i)。
 起初，机器人位于编号为 00 的建筑，初始能量为 EE。
 机器人每次跳到右侧的下一座建筑（从 kk 到 k+1k+1），其能量变化如下：

- 如果 H(k+1)>EH(k+1) > E，则机器人损失 H(k+1)−EH(k+1) - E 的能量；
- 如果 H(k+1)≤EH(k+1) \leq E，则机器人获得 E−H(k+1)E - H(k+1) 的能量。

机器人需要保证能量值始终非负，目标是跳到编号为 NN 的建筑。
 求机器人成功到达建筑 NN 所需的最小初始能量 EE。

------

### **输入描述：**

第一行输入整数 NN（1≤N≤1000001 \leq N \leq 100000），表示建筑的数量。
 接下来 NN 个整数 H(1),H(2),...,H(N)H(1), H(2), ..., H(N)（0≤H(i)≤1090 \leq H(i) \leq 10^9），表示每座建筑的高度。

------

### **输出描述：**

输出一个整数，表示机器人成功到达建筑 NN 所需的最小初始能量 EE。

------

### **算法知识：**

1. 二分查找：

   - 设定初始能量的搜索范围 [l,r][l, r]

     ，其中：

     - l=0（理论上的最低初始能量）
     - r 为建筑的最大高度（最坏情况下需要的能量）

   - 通过二分查找最小的 E，使得机器人可以通关。

2. 贪心模拟通关过程：

   - 从建筑 1 依次跳跃到建筑 N，计算能量变化。
   - 若能量为负数，则当前初始能量不足。
   - 若能量在任意时刻超过最高建筑的高度，说明必然能通关，可以直接返回 `true`。

------

### **代码实现**

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 100001;
vector<int> arr(MAXN);
int n;

// 计算机器人通关所需的最小初始能量，使用二分查找
int compute(int l, int r, int max);
// 判断以 energy 为初始能量时，是否能通关
bool canPass(int energy, int max);

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    while (cin >> n) {
        int l = 0, r = 0;
        for (int i = 1; i <= n; i++) {
            cin >> arr[i];
            r = max(r, arr[i]); // 记录最大高度
        }
        cout << compute(l, r, r) << "\n";
    }
    return 0;
}

// 二分查找，计算通关所需的最小初始能量
// l: 二分查找左边界
// r: 二分查找右边界
// max: 所有建筑的最大高度
int compute(int l, int r, int max) {
    int ans = -1;
    while (l <= r) {
        int m = l + (r - l) / 2; // 计算中点能量
        if (canPass(m, max)) {
            ans = m; // 记录当前可行解
            r = m - 1; // 尝试更小的初始能量
        } else {
            l = m + 1; // 增加初始能量
        }
    }
    return ans;
}

// 判断初始能量 energy 是否足够通关
// max: 所有建筑的最大高度
bool canPass(int energy, int max) {
    for (int i = 1; i <= n; i++) {
        if (energy <= arr[i]) {
            energy -= arr[i] - energy; // 失去能量
        } else {
            energy += energy - arr[i]; // 增加能量
        }
        if (energy >= max) return true; // 能量超过最大高度，必然通关
        if (energy < 0) return false; // 能量变负，无法通关
    }
    return true;
}
```

------

### **过程分析**

1. **输入处理**：
   - 读取 N 并存储建筑高度 H[i]。
   - 找到最高建筑的高度 r，作为二分查找的上限。
2. **二分查找**：
   - 设定初始能量范围 [0,r][0, r] 进行二分。
   - 计算当前能量 midmid 是否可行（`canPass(mid, max)`）。
   - 如果可以通关，记录答案，并尝试更小的能量（`r = mid - 1`）。
   - 否则，增加能量（`l = mid + 1`）。
3. **模拟通关过程**：
   - 遍历建筑高度数组：
     - 若当前能量小于建筑高度，损失能量。
     - 否则，能量增加（能量变化模拟公式）。
     - 若能量大于最高建筑高度，则直接返回 `true`（确保能通关）。
     - 若能量变负，则失败，返回 `false`。
4. **输出最终结果**：
   - 最小的可行初始能量 `ans`。

------

### **复杂度分析**

- **二分查找部分**：搜索范围是 [0,max⁡(H)][0, \max(H)]，最多进行 O(log⁡max⁡(H)) 次查找。
- **模拟通关过程**：每次检查能否通关需要遍历 O(N)。
- **总时间复杂度**：O(Nlog⁡max⁡(H))。
- **空间复杂度**：O(1)（仅使用常数级额外空间）。

------

**总结**：

- 该问题利用 **二分查找 + 贪心模拟** 来高效求解。
- 通过二分查找找到最小的初始能量，并使用模拟方法判断是否能通关。
- 复杂度控制在 **O(Nlog⁡max⁡(H))O(N \log \max(H))**，适用于大规模输入数据。