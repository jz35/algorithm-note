# 第63课：双向广搜

## 一、双向广搜概述

### （一）前置知识

- **经典递归过程解析**：讲解038
- **根据数据量猜解法**：讲解043
- **宽度优先遍历及其扩展**：讲解062
- **图的基础知识**：讲解059~讲解065

### （二）双向广搜的常见用途

1. **小优化**：
   - **剪枝策略**：分两侧展开分支，哪侧数量少就从哪侧展开。
2. **重要用途**：
   - **特征**：全量样本不允许递归完全展开，但半量样本可以完全展开。
   - **过程**：把数据分成两部分，每部分各自展开计算结果，然后设计两部分结果的整合逻辑。

## 二、双向广搜的实现

### （一）基本思想

- **正向BFS**：从起点开始，逐层展开。
- **反向BFS**：从终点开始，逐层展开。
- **相遇条件**：正向和反向的BFS在某一层相遇，即找到最短路径。

### （二）优点

- **效率提升**：相比单向BFS，双向BFS可以显著减少搜索空间，提高效率。
- **适用场景**：适用于起点和终点明确，且路径长度较短的问题。

## 三、题目解析

### （一）题目 1：单词接龙

**问题描述**：

- 给定两个单词 `beginWord` 和 `endWord`，以及一个字典 `wordList`。
- 找出从 `beginWord` 到 `endWord` 的最短转换序列，每对相邻的单词只差一个字母。
- 返回最短转换序列中的单词数目。如果不存在这样的转换序列，返回 0。

**解题思路**：

1. **正向BFS**：从 `beginWord` 开始，逐层展开，记录每个单词的前驱单词。
2. **反向BFS**：从 `endWord` 开始，逐层展开，记录每个单词的后继单词。
3. **相遇条件**：当正向和反向的BFS在某一层相遇时，找到最短路径。
4. **路径生成**：从相遇点回溯，生成最短路径。

**测试链接**：[Word Ladder](https://leetcode.cn/problems/word-ladder)

### （二）题目 2：零食问题 & 世界冰球锦标赛

**问题描述**：

- 牛牛准备参加春游，背包容量为 w。
- 牛牛家里有 n 袋零食，每袋零食体积为 v[i]。
- 求在总体积不超过背包容量的情况下，有多少种零食放法（总体积为0也算一种放法）。

**数据量**：

- 1 <= n <= 40
- 1 <= w <= 2 * 10^9
- 0 <= v[i] <= 10^9

**解题思路**：

1. **数据分割**：将零食分成两部分，每部分分别进行BFS。
2. **正向BFS**：从第一部分零食开始，逐层展开，记录每种组合的总体积。
3. **反向BFS**：从第二部分零食开始，逐层展开，记录每种组合的总体积。
4. **结果整合**：设计两部分结果的整合逻辑，计算总放法数。

**测试链接**：

- [NowCoder](https://www.nowcoder.com/practice/d94bb2fa461d42bcb4c0f2b94f5d4281)
- [Luogu](https://www.luogu.com.cn/problem/P4799)

### （三）题目 3：最接近目标值的子序列和

**问题描述**：

- 给定一个整数数组 `nums` 和一个目标值 `goal`。
- 从 `nums` 中选出一个子序列，使子序列元素总和最接近 `goal`。
- 返回 `abs(sum - goal)` 的最小值。

**数据量**：

- 1 <= nums.length <= 40
- -10^7 <= nums[i] <= 10^7
- -10^9 <= goal <= 10^9

**解题思路**：

1. **数据分割**：将数组分成两部分，每部分分别进行BFS。
2. **正向BFS**：从第一部分数组开始，逐层展开，记录每种组合的总和。
3. **反向BFS**：从第二部分数组开始，逐层展开，记录每种组合的总和。
4. **结果整合**：设计两部分结果的整合逻辑，计算最接近目标值的子序列和。

**测试链接**：[Closest Subsequence Sum](https://leetcode.cn/problems/closest-subsequence-sum)