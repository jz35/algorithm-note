# 算法第10课：合并两个有序链表

### 日期：2025年01月07日

## 课程内容：

- **链表基础**：介绍了链表的基本概念和操作，包括节点的定义和链表的遍历.
- **题目背景**：讲解了合并两个有序链表的题目背景和意义，强调了链表题目在笔试和面试中检验编程能力的重要性.
- **算法思路**：详细阐述了合并两个有序链表的算法思路，包括递归和迭代两种方法，重点讲解了迭代法的具体实现步骤.
- **代码实现**：展示了合并两个有序链表的Java代码实现，并对关键代码进行了注释和解释，帮助理解算法的具体实现过程.



## 算法题目：

- **题目描述**：将两个升序链表合并为一个新的升序链表并返回，新链表是通过拼接给定的两个链表的所有节点组成的.
- **题目链接**：[LeetCode - 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)



## 知识点：

- **链表数据结构**：链表是一种线性数据结构，由一系列节点组成，每个节点包含一个值和一个指向下一个节点的指针.链表的特点是可以动态地增加或删除节点，但不支持随机访问.
- **双指针技巧**：在合并两个有序链表时，使用双指针技巧可以高效地遍历两个链表，比较节点值并进行合并操作.一个指针用于遍历第一个链表，另一个指针用于遍历第二个链表.
- **迭代算法思想**：迭代算法通过重复执行一系列操作来逐步解决问题.在合并链表的过程中，通过迭代比较两个链表的节点值，并将较小的节点连接到新链表中，直到遍历完所有节点.



## 参考代码：

```cpp
// 将两个升序链表合并为一个新的 升序 链表并返回
// 新链表是通过拼接给定的两个链表的所有节点组成的
class Solution {
public:
    struct ListNode {
        int val;
        ListNode *next;
        ListNode(int x) : val(x), next(nullptr) {}
    };

    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        // 创建一个虚拟头节点，方便后续操作
        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;

        // 遍历两个链表，直到其中一个链表为空
        while (l1 != nullptr && l2 != nullptr) {
            if (l1->val <= l2->val) {
                cur->next = l1;  // 将l1的当前节点连接到新链表
                l1 = l1->next;   // 移动l1的指针
            } else {
                cur->next = l2;  // 将l2的当前节点连接到新链表
                l2 = l2->next;   // 移动l2的指针
            }
            cur = cur->next;     // 移动新链表的指针
        }

        // 将剩余的节点连接到新链表
        cur->next = l1 != nullptr ? l1 : l2;

        // 返回合并后链表的头节点
        ListNode* mergedHead = dummy->next;
        delete dummy;  // 释放虚拟头节点
        return mergedHead;
    }
};
```

### 过程解析：

假设我们有两个升序链表：

- 链表1：1 -> 3 -> 5
- 链表2：2 -> 4 -> 6

合并过程如下：

1. **初始化**：创建一个虚拟头节点 `dummy`，并设置一个指针 `cur` 指向 `dummy`.
2. **遍历比较**：
   - 比较链表1的头节点（值为1）和链表2的头节点（值为2），将值为1的节点连接到新链表，`cur` 移动到该节点，链表1的指针移动到下一个节点（值为3）.
   - 比较链表1的当前节点（值为3）和链表2的头节点（值为2），将值为2的节点连接到新链表，`cur` 移动到该节点，链表2的指针移动到下一个节点（值为4）.
   - 依次类推，继续比较并连接节点，直到其中一个链表为空.
3. **连接剩余节点**：将链表1或链表2中剩余的节点连接到新链表.
4. **返回结果**：返回合并后链表的头节点，即 `dummy->next`.

最终合并后的链表为：1 -> 2 -> 3 -> 4 -> 5 -> 6.