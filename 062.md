# 第62课：宽度优先遍历及其扩展

## 一、宽度优先遍历（BFS）基础

### （一）基本概念

- **特点**：逐层扩散，从源头点到目标点扩散了几层，最短路就是多少。
- **适用场景**：任意两个节点之间的相互距离相同（无向图）。
- **起点**：可以是单个源头，也可以是多个源头。
- **队列使用**：频繁使用队列，形式可以是单点弹出或者整层弹出。
- **状态标记**：进入队列的节点需要标记状态，防止同一个节点重复进出队列。
- **剪枝策略**：可能会包含剪枝策略的设计。

### （二）难点

- **节点如何找到路**：设计节点的扩散方式。
- **路的展开**：如何高效地展开路径。
- **剪枝设计**：如何设计剪枝策略以提高效率。

## 二、01 BFS

### （一）适用场景

- 图中所有边的权重只有0和1两种值，求源点到目标点的最短距离。

### （二）算法步骤

1. **初始化**：
   - `distance[i]` 表示从源点到 i 点的最短距离，初始时所有点的 `distance` 设置为无穷大。
   - 源点进入双端队列，`distance[源点] = 0`。
2. **处理过程**：
   - 双端队列头部弹出节点 x。
   - 如果 x 是目标点，返回 `distance[x]`。
   - 考察从 x 出发的每一条边，假设某边去 y 点，边权为 w：
     - 如果 `distance[y] > distance[x] + w`，处理该边；否则忽略该边。
     - 更新 `distance[y] = distance[x] + w`。
     - 如果 w == 0，y 从头部进入双端队列；如果 w == 1，y 从尾部进入双端队列。
3. **结束条件**：
   - 双端队列为空时停止。

### （三）时间复杂度

- **时间复杂度**：O(节点数量 + 边的数量)。
- **为什么不能用传统 BFS**：传统 BFS 无法处理边权为 0 和 1 的情况，01 BFS 利用双端队列优化了这一点。

### （四）正确性证明

- 01 BFS 的正确性基于 BFS 的逐层扩散特性，通过双端队列确保每次处理的节点都是当前最短路径上的节点。

## 三、宽度优先遍历与优先级队列结合

### （一）应用场景

- 更进一步的内容会在讲 Dijkstra 算法时说明。

## 四、宽度优先遍历与深度优先遍历结合

### （一）应用场景

- **BFS 建图**：利用 BFS 生成图的结构。
- **DFS 生成路径**：利用 DFS 从 BFS 生成的图中生成路径。

## 五、题目解析

### （一）题目 1：地图分析

**问题描述**：

- 给定一个 n x n 的网格 `grid`，每个单元格用 0 和 1 标记，0 代表海洋，1 代表陆地。
- 找出一个海洋单元格，该海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。
- 如果网格上只有陆地或者海洋，请返回 -1。
- 距离定义为曼哈顿距离。

**解题思路**：

- 使用 BFS 从所有陆地单元格开始，逐层扩散，记录每个海洋单元格到最近陆地单元格的距离。
- 返回最远的海洋单元格到最近陆地单元格的距离。

**测试链接**：[As Far from Land as Possible](https://leetcode.cn/problems/as-far-from-land-as-possible/)

### （二）题目 2：贴纸拼词

**问题描述**：

- 有 n 种不同的贴纸，每个贴纸上都有一个小写的英文单词。
- 拼写出给定的字符串 `target`，方法是从贴纸中切割单个字母并重新排列。
- 返回拼出 `target` 的最小贴纸数量。如果任务不可能，则返回 -1。

**解题思路**：

- 使用 BFS，将每个状态表示为当前还需要拼出的字母集合。
- 每次从队列中取出一个状态，尝试使用每种贴纸来减少当前状态中的字母数量。
- 使用剪枝策略避免重复状态。

**测试链接**：[Stickers to Spell Word](https://leetcode.cn/problems/stickers-to-spell-word/)

### （三）题目 3：到达角落需要移除障碍物的最小数目

**问题描述**：

- 给定一个 m x n 的二维整数数组 `grid`，每个单元格是 0（空）或 1（障碍物）。
- 从左上角 (0, 0) 移动到右下角 (m - 1, n - 1)，返回需要移除的障碍物的最小数目。

**解题思路**：

- 使用 BFS，从起点开始，逐层扩散，记录到达每个单元格需要移除的障碍物数目。
- 返回到达终点时的最小数目。

**测试链接**：[Minimum Obstacle Removal to Reach Corner](https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/)

### （四）题目 4：使网格图至少有一条有效路径的最小代价

**问题描述**：

- 给定一个 m x n 的网格图 `grid`，每个格子都有一个数字，表示下一步走的方向。
- 从最左上角的格子 (0, 0) 出发，有效路径为每一步都顺着数字对应方向走，最终在最右下角的格子 (m - 1, n - 1) 结束。
- 可以花费 1 的代价修改一个格子中的数字，但每个格子中的数字只能修改一次。
- 返回让网格图至少有一条有效路径的最小代价。

**解题思路**：

- 使用 BFS，从起点开始，逐层扩散，记录到达每个单元格的最小代价。
- 返回到达终点时的最小代价。

**测试链接**：[Minimum Cost to Make at Least One Valid Path in a Grid](https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/)

### （五）题目 5：二维接雨水

**问题描述**：

- 给定一个 m x n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度。
- 计算图中形状最多能接多少体积的雨水。

**解题思路**：

- 使用 BFS，从边界开始，逐层扩散，记录每个单元格的最低高度。
- 计算每个单元格的雨水量，累加得到总雨水量。

**测试链接**：[Trapping Rain Water II](https://leetcode.cn/problems/trapping-rain-water-ii/)

### （六）题目 6：单词接龙 II

**问题描述**：

- 给定两个单词 `beginWord` 和 `endWord`，以及一个字典 `wordList`。
- 找出所有从 `beginWord` 到 `endWord` 的最短转换序列。

**解题思路**：

- 使用 BFS，从 `beginWord` 开始，逐层扩散，记录每个单词的前驱单词。
- 使用 DFS 从 `endWord` 回溯生成所有路径。

**测试链接**：[Word Ladder II](https://leetcode.cn/problems/word-ladder-ii/)