# 算法第38课：常见经典递归过程解析

## 题目：打印n层汉诺塔问题的最优移动轨迹

### 题目描述：

给定一个正整数 `n`，表示汉诺塔的层数。汉诺塔问题的目标是将 `n` 个大小不一的圆盘从一个柱子（称为“左”柱）移动到另一个柱子（称为“右”柱），过程中可以使用一个辅助柱子（称为“中”柱）。移动过程中需满足以下规则：

1. 每次只能移动一个圆盘。
2. 每个柱子上，较大的圆盘不能放在较小的圆盘上面。
3. 最终所有圆盘都需移动到“右”柱上。

请打印出移动的最优轨迹。

### 输入描述：

一个正整数 `n`，表示汉诺塔的层数。

### 输出描述：

按照移动顺序，打印每一步的移动轨迹，格式为：“移动圆盘 X 从 A 到 B”，其中 X 为圆盘编号，A 为起始柱子，B 为目标柱子。

### 算法知识：

- **递归**：通过递归的方式实现汉诺塔问题的最优移动轨迹。

### 题目链接：

无

### 代码实现（Java）：

```java
package class038;

public class Code07_TowerOfHanoi {

    public static void hanoi(int n) {
        if (n > 0) {
            f(n, "左", "右", "中");
        }
    }

    public static void f(int i, String from, String to, String other) {
        if (i == 1) {
            System.out.println("移动圆盘 1 从 " + from + " 到 " + to);
        } else {
            f(i - 1, from, other, to);
            System.out.println("移动圆盘 " + i + " 从 " + from + " 到 " + to);
            f(i - 1, other, to, from);
        }
    }

    public static void main(String[] args) {
        int n = 3;
        hanoi(n);
    }
}
```

## C++实现：

```cpp
#include <iostream>
using namespace std;

class Solution {
public:
    // 打印n层汉诺塔问题的最优移动轨迹
    void hanoi(int n) {
        if (n > 0) {
            moveDisks(n, "左", "右", "中");
        }
    }

    // 递归函数来解决汉诺塔问题
    void moveDisks(int i, string from, string to, string other) {
        if (i == 1) {
            cout << "移动圆盘 1 从 " << from << " 到 " << to << endl;  // 基本情况：直接移动最小盘子
        } else {
            // 将前 (i-1) 个盘子从 from 移到 other
            moveDisks(i - 1, from, other, to);
            // 移动第 i 个盘子
            cout << "移动圆盘 " << i << " 从 " << from << " 到 " << to << endl;
            // 将 (i-1) 个盘子从 other 移到 to
            moveDisks(i - 1, other, to, from);
        }
    }
};

int main() {
    Solution solution;
    int n = 3;  // 设定盘子的数量为 3
    solution.hanoi(n);  // 调用汉诺塔函数输出最优移动轨迹
    return 0;
}
```

### 代码执行过程示例：

假设我们输入的是 `n = 3`，即我们有 3 个盘子需要从“左”柱子移动到“右”柱子。我们按照汉诺塔的最优解进行移动。

1. 第一次递归：

   - ```
     moveDisks(3, "左", "右", "中")：我们要移动 3 个盘子，从“左”到“右”，使用“中”作为辅助。
     ```

     - 首先，我们递归处理前 2 个盘子，从“左”到“中”，使用“右”作为辅助。

       - ```
         moveDisks(2, "左", "中", "右")：
         ```

         - 递归处理前 1 个盘子，从“左”到“右”，使用“中”作为辅助。

           - ```
             moveDisks(1, "左", "右", "中")：
             ```

             - 输出：“移动圆盘 1 从 左 到 右”。

         - 输出：“移动圆盘 2 从 左 到 中”。

         - 递归处理前 1 个盘子，从“右”到“中”，使用“左”作为辅助。

           - ```
             moveDisks(1, "右", "中", "左")：
             ```

             - 输出：“移动圆盘 1 从 右 到 中”。

     - 输出：“移动圆盘 3 从 左 到 右”。

     - 接下来，我们递归处理前 2 个盘子，从“中”到“右”，使用“左”作为辅助。

       - ```
         moveDisks(2, "中", "右", "左")：
         ```

         - 递归处理前 1 个盘子，从“中”到“左”，使用“右”作为辅助。

           - ```
             moveDisks(1, "中", "左", "右")：
             ```

             - 输出：“移动圆盘 1 从 中 到 左”。

         - 输出：“移动圆盘 2 从 中 到 右”。

         - 递归处理前 1 个盘子，从“左”到“右”，使用“中”作为辅助。

           - ```
             moveDisks(1, "左", "右", "中")：
             ```

             - 输出：“移动圆盘 1 从 左 到 右”。

### 总结：

对于 3 个盘子的汉诺塔问题，最优的移动顺序是：

```
移动圆盘 1 从 左 到 右
移动圆盘 2 从 左 到 中
移动圆盘 1 从 右 到 中
移动圆盘 3 从 左 到 右
移动圆盘 1 从 中 到 左
移动圆盘 2 从 中 到 右
移动圆盘 1 从 左 到 右
```

这段程序使用递归的方法来计算最优的移动步骤。每次将问题分解为两个子问题：一个是移动 `n-1` 个盘子，另一个是移动剩下的最大盘子。递归的过程通过分解问题并在每一层调用 `moveDisks` 函数实现，直到剩下的盘子数为 1 时，直接执行移动。

### 执行过程详解：

1. **`moveDisks(3, "左", "右", "中")`**：处理从“左”到“右”的移动，递归处理前 2 个盘子，从“左”到“中”，使用“右”作为辅助。
2. **`moveDisks(2, "左", "中", "右")`**：递归处理前 1 个盘子，从“左”到“右”，使用“中”作为辅助，移动圆盘 1。
3. **`moveDisks(1, "左", "右", "中")`**：移动圆盘 1 从“左”到“右”。
4. 然后移动第二个盘子，依次递归处理。