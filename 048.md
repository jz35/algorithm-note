

# 第48课：二维前缀和、二维差分、离散化技巧

## 一、二维前缀和

### （一）原理

- **目的**：通过预处理生成一个二维前缀和数组`sum`，使得后续查询二维数组任意范围的累加和操作的时间复杂度为O(1)。

- **定义**：`sum[i][j]`表示从左上角(0,0)到右下角(i,j)的范围内的累加和。

- **计算公式**：

  sum[i][j]=sum[i][j−1]+sum[i−1][j]−sum[i−1][j−1]+原数组对应值

- **查询公式**：查询左上角(a,b)到右下角(c,d)的范围累加和为：

  sum[c][d]−sum[c][b−1]−sum[a−1][d]+sum[a−1][b−1]

- **优化**：在实际实现中，通常补上第0行和第0列，这样可以减少很多条件判断，避免边界情况的复杂处理。当然，也可以根据个人习惯选择不补。

### （二）代码实现

cppCopy

```cpp
// 初始化二维前缀和数组
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + arr[i][j];
    }
}

// 查询函数
int query(int a, int b, int c, int d) {
    return sum[c][d] - sum[c][b - 1] - sum[a - 1][d] + sum[a - 1][b - 1];
}
```

### （三）相关题目

1. **二维前缀和模板**：[LeetCode - Range Sum Query 2D - Immutable](https://leetcode.cn/problems/range-sum-query-2d-immutable/)
2. **边框为1的最大正方形**：给定一个由0和1组成的二维网格`grid`，找出边界全部由1组成的最大正方形子网格，并返回该子网格中的元素数量。如果不存在，则返回0。测试链接：[LeetCode - Largest 1-Bordered Square](https://leetcode.cn/problems/largest-1-bordered-square/)

## 二、二维差分

### （一）原理

- **目的**：在二维数组中，快速处理批量的范围更新操作，并在所有操作完成后能够快速得到每个位置的最终值。

- **核心思想**：通过差分数组`diff`来记录每个操作对数组的影响，最后通过构建函数`build`来计算每个位置的最终值。

- **操作方法**：

  - **add操作**：对于一个操作`add(a, b, c, d, v)`，表示在左上角(a,b)到右下角(c,d)的范围内每个数字加上v。实现方式为：

    cppCopy

    ```cpp
    void add(int a, int b, int c, int d, int v) {
        diff[a][b] += v;
        diff[c + 1][b] -= v;
        diff[a][d + 1] -= v;
        diff[c + 1][d + 1] += v;
    }
    ```

  - **build操作**：在所有add操作完成后，通过以下方式构建最终的二维数组：

    cppCopy

    ```cpp
    void build() {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];
            }
        }
    }
    ```

- **优化**：真实数据可以用一圈0包裹起来，这样可以减少很多边界讨论。

### （二）代码实现

cppCopy

```cpp
// 差分数组初始化
int diff[n + 2][m + 2] = {0};

// add操作
void add(int a, int b, int c, int d, int v) {
    diff[a][b] += v;
    diff[c + 1][b] -= v;
    diff[a][d + 1] -= v;
    diff[c + 1][d + 1] += v;
}

// 构建最终数组
void build() {
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            diff[i][j] += diff[i - 1][j] + diff[i][j - 1] - diff[i - 1][j - 1];
        }
    }
}
```

### （三）相关题目

1. **二维差分模板**：
   - [牛客网 - 二维差分模板](https://www.nowcoder.com/practice/50e1a93989df42efb0b1dec386fb4ccc)
   - [洛谷 - P3397 二维差分](https://www.luogu.com.cn/problem/P3397)
2. **用邮票贴满网格图**：给定一个m * n的二进制矩阵`grid`，每个格子要么为0（空），要么为1（被占据）。给定邮票的尺寸为`stampHeight * stampWidth`，要求将邮票贴进矩阵中，覆盖所有空格子，不覆盖任何被占据的格子，邮票可以相互重叠，但不能旋转，且必须完全在矩阵内。如果可以满足这些要求，则返回true，否则返回false。测试链接：[LeetCode - Stamping the Grid](https://leetcode.cn/problems/stamping-the-grid/)

## 三、离散化技巧

### （一）原理

- **定义**：离散化是一种将连续的、无限的值域映射到有限的、离散的值域的技术。在算法中，离散化通常用于处理那些值域很大但实际用到的值很少的情况，通过将这些值映射到一个较小的范围内，可以节省空间和时间。
- **应用场景**：当问题中的数据范围很大，但实际参与计算的值很少时，可以使用离散化技巧。例如，在处理一些几何问题、区间问题等时，离散化可以大大简化问题。

### （二）相关题目

1. **最强祝福力场**：小扣在探索丛林的过程中，发现了传说中的“落寞的黄金之都”。他使用探测仪监测到了带有“祝福”效果的力场，力场的分布记录为`forceField[i] = [x,y,side]`，表示第i片力场覆盖以坐标(x,y)为中心，边长为side的正方形区域。力场强度等于覆盖该点的力场数量。请求出这片地带中力场强度最强处的力场强度。注意：力场范围的边缘同样被力场覆盖。测试链接：[LeetCode - 最强祝福力场](https://leetcode.cn/problems/xepqZ5/)

### （三）离散化技巧示例

以“最强祝福力场”为例，离散化过程如下：

- **提取关键点**：从所有力场的中心点和边界点中提取出所有可能影响力场强度的点。
- **排序去重**：将这些点按照某种顺序（通常是从小到大）排序，并去除重复的点。
- **映射**：将排序后的点映射到一个连续的整数序列中，例如，将最小的点映射为1，次小的点映射为2，依此类推。
- **应用**：在处理问题时，使用映射后的值代替原始值，从而将问题简化为在一个较小的范围内进行计算。