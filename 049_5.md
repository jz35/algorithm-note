# 第49课：滑动窗口技巧和相关题目

好的，以下是详细整理的笔记，结合了算法中的 `debt` 变量的作用：

------

### **题目描述：**

给定一个只含有 `'Q'`, `'W'`, `'E'`, `'R'` 四种字符，且长度为 `n` 的字符串 `s`。假如在该字符串中，这四个字符都恰好出现 `n/4` 次，那么它就是一个「平衡字符串」。

你需要通过「替换一个子串」的方式，使原字符串 `s` 变成一个「平衡字符串」。你可以用与「待替换子串」长度相同的任何其他字符串来完成替换。请返回待替换子串的最小可能长度。如果原字符串自身就是一个平衡字符串，则返回 0。

------

### **输入描述：**

- 一个长度为 `n` 的字符串 `s`，仅包含字符 `'Q'`, `'W'`, `'E'`, `'R'`。

### **输出描述：**

- 返回一个整数，表示最小替换子串的长度。如果字符串已经是平衡的，返回 0。

### **算法知识：**

#### 1. **平衡字符串的定义：**

平衡字符串是指字符串中的每个字符（`'Q'`, `'W'`, `'E'`, `'R'`）恰好出现 `n/4` 次。其中 `n` 是字符串的长度。若当前字符串满足条件，则无需替换，返回 0。

#### 2. **滑动窗口算法：**

这是一个典型的滑动窗口问题，我们使用两个指针 `l` 和 `r` 来表示一个滑动窗口，寻找最小的子串，这个子串的替换后可以使字符串变成平衡字符串。

#### 3. **窗口的调整：**

我们希望通过调整滑动窗口的大小，找到最小的窗口，该窗口内的字符通过替换可以使得整个字符串满足平衡条件。

#### 4. **`debt` 变量的含义：**

`debt` 变量用于表示字符串中每个字符的“缺口”，即字符的出现次数与目标平衡字符串要求之间的差距。具体来说：

- 假设目标平衡字符串中每个字符应该出现 `n/4` 次。
- `cnts[i]` 数组表示当前字符 `i` 在字符串中的实际出现次数，`n/4 - cnts[i]` 计算了字符 `i` 的缺失数量。
- `debt` 的初始值是所有字符的缺失数量之和。

#### 5. **`debt` 的更新过程：**

- 当滑动窗口右侧扩展时（即 r 增大），我们计算当前字符的出现次数，并更新 debt：
  - 如果某个字符的数量满足或超过了目标值（即 `cnts[i] >= n/4`），我们减少 `debt`。
  - 如果某个字符的数量不足目标值，我们增加 `debt`。
- 当 `debt == 0` 时，意味着当前窗口内的字符已经满足了平衡字符串的要求。此时，我们可以尝试通过收缩窗口来找到最小的满足条件的子串。

#### 6. **最小窗口的求解：**

当 `debt == 0` 时，我们计算当前窗口的大小。如果该窗口的大小小于先前记录的最小长度，则更新最小长度。

#### 7. **算法的时间复杂度：**

- 滑动窗口的左右指针各自遍历整个字符串一次，所以时间复杂度是 O(n)，其中 `n` 是字符串的长度。
- 更新 `debt` 和 `cnts` 的操作都是 O(1)，所以整个算法的时间复杂度是 O(n)。

------

### **代码实现：**

```C++
class Solution {
public:
    int balancedString(string s) {
        int n = s.length();
        vector<int> cnts(4, 0);
        vector<int> s_map(n, 0);
        
        // 统计字符出现次数
        for (int i = 0; i < n; i++) {
            char c = s[i];
            if (c == 'Q') s_map[i] = 0;
            else if (c == 'W') s_map[i] = 1;
            else if (c == 'E') s_map[i] = 2;
            else if (c == 'R') s_map[i] = 3;
            cnts[s_map[i]]++;
        }
        
        int debt = 0;
        // 更新缺失字符的数量
        for (int i = 0; i < 4; i++) {
            if (cnts[i] < n / 4) {
                cnts[i] = 0;
            } else {
                cnts[i] = n / 4 - cnts[i];
                debt -= cnts[i];
            }
        }
        
        if (debt == 0) {
            return 0;
        }

        int ans = INT_MAX;
        for (int l = 0, r = 0; r < n; r++) {
            if (cnts[s_map[r]]++ < 0) {
                debt--;
            }
            if (debt == 0) {
                while (cnts[s_map[l]] > 0) {
                    cnts[s_map[l++]]--;
                }
                ans = min(ans, r - l + 1);
            }
        }
        
        return ans;
    }
};
```

### **代码解释：**

1. **初始化：**
   - 使用 `cnts` 数组统计每个字符的出现次数。
   - 使用 `debt` 来记录当前字符的缺失数量。`debt == 0` 时，表示当前窗口已经满足平衡条件。
2. **滑动窗口：**
   - 使用两个指针 `l` 和 `r` 来维护一个滑动窗口。每次扩展右边界 `r` 时，更新字符的出现次数和 `debt`。
   - 当 `debt == 0` 时，尝试收缩左边界 `l`，找到最小满足条件的子串。
3. **返回结果：**
   - 如果字符串已经是平衡字符串，返回 0。
   - 否则，返回最小替换子串的长度。

------

### **总结：**

- **`debt`**：是一个关键变量，用于追踪每个字符的缺失数量，表示还需要通过替换来满足目标平衡字符串的条件。
- 通过滑动窗口来动态调整窗口大小，使得窗口内的字符满足平衡字符串的条件。