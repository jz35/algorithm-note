# 第35课：数据结构基础设计

### 前置知识
- **动态数组与扩容分析**：理解动态数组的原理，如Java中的ArrayList，其在扩容时会创建一个更大的数组，并将原数组元素复制过去，扩容操作的时间复杂度为O(n)，但通过摊还分析，单次插入操作的平均时间复杂度为O(1)。
- **链表入门**：掌握链表的基本概念、操作，包括单链表、双链表的节点结构、插入、删除等操作，以及它们的时间复杂度特点，例如在链表头部插入节点的时间复杂度为O(1)，但在链表尾部或中间插入、删除节点的时间复杂度为O(n)。
- **堆结构**：了解堆的性质，如大顶堆（父节点的值大于等于子节点的值）、小顶堆（父节点的值小于等于子节点的值），以及堆的插入、删除等操作的时间复杂度，通常为O(logn)。
- **哈希表、有序表与比较器的使用**：熟悉哈希表的原理，包括哈希函数的设计、冲突解决方法（如链地址法、开放定址法等），以及哈希表的插入、查找、删除操作的时间复杂度，在理想情况下为O(1)。掌握有序表的概念，以及比较器在排序、查找等操作中的应用。

### 数据结构设计高频题

#### 题目1：setAll功能的哈希表
- **问题描述**：设计一个哈希表，除了实现常规的插入、删除、查找操作外，还需要支持setAll功能，即一次性将所有键对应的值设置为同一个值。
- **解决方案**：可以使用==两个哈希表==来实现。一个哈希表用于存储键值对，另一个哈希表用于存储键和一个标记值。当调用setAll功能时，记录下当前的标记值和对应的值，对于后续的插入、删除、查找操作，都需要先检查键对应的标记值是否与setAll操作时的标记值一致，如果不一致，则返回setAll操作时的值。

#### 题目2：实现LRU结构
- **问题描述**：设计一个最近最少使用（LRU）缓存结构，要求在O(1)时间内完成get和put操作。get操作表示获取缓存中的某个键对应的值，如果键不存在则返回-1；put操作表示插入或更新键值对，当缓存容量达到上限时，需要删除最久未使用的键值对。
- **解决方案**：可以使用==双向链表和哈希表==结合的方式来实现。双向链表用于维护键值对的使用顺序，哈希表用于快速定位键值对在链表中的位置。每次get操作时，将对应的键值对移动到链表头部；每次put操作时，如果键已存在则更新值并将其移动到链表头部，如果键不存在则插入到链表头部，并在哈希表中记录键和节点的映射关系，如果缓存容量达到上限，则删除链表尾部的节点，并在哈希表中删除对应的键。

#### 题目3：插入、删除和获取随机元素O(1)时间的结构
- **问题描述**：设计一个数据结构，支持在O(1)时间内完成插入、删除和获取随机元素的操作。
- **解决方案**：可以使用==数组和哈希表结合==的方式来实现。数组用于存储元素，哈希表用于存储元素和其在数组中的索引的映射关系。插入操作时，将元素添加到数组尾部，并在哈希表中记录元素和索引的映射关系；删除操作时，通过哈希表找到元素在数组中的索引，然后将数组尾部的元素移动到该位置，并更新哈希表中对应的映射关系，最后删除数组尾部的元素和哈希表中的记录；获取随机元素操作时，直接通过随机数生成器生成一个数组索引，然后返回该索引对应的元素。

#### 题目4：插入、删除和获取随机元素O(1)时间且允许有重复数字的结构
- **问题描述**：设计一个数据结构，支持在O(1)时间内完成插入、删除和获取随机元素的操作，并且允许有重复数字。
- **解决方案**：在题目3的基础上进行扩展。可以使用一个哈希表来存储数字和其在数组中索引的集合的映射关系。插入操作时，将数字添加到数组尾部，并在哈希表中记录数字和索引的映射关系，如果数字已存在，则将索引添加到对应的集合中；删除操作时，通过哈希表找到数字在数组中的任意一个索引，然后将数组尾部的数字移动到该位置，并更新哈希表中对应的映射关系，如果数字在数组中只有一个索引，则直接删除哈希表中的记录，最后删除数组尾部的数字；获取随机元素操作与题目3相同。

#### 题目5：快速获得数据流的中位数的结构
- **问题描述**：设计一个数据结构，能够快速获得数据流的中位数。
- **解决方案**：可以使用==两个堆==来实现，一个大顶堆用于存储较小的一半数字，一个小顶堆用于存储较大的一半数字。当插入一个新的数字时，根据数字的大小将其插入到对应的堆中，并保证两个堆的大小差不超过1。如果两个堆的大小相等，则中位数为两个堆顶元素的平均值；如果两个堆的大小不相等，则中位数为较大堆的堆顶元素。

#### 题目6：最大频率栈
- **问题描述**：设计一个栈，支持push、pop和getMaxFrequency操作，其中getMaxFrequency操作用于获取栈中出现频率最高的元素的频率。
- **解决方案**：可以使用==哈希表和栈==结合的方式来实现。哈希表用于存储元素和其出现频率的映射关系，栈用于存储元素。每次push操作时，更新哈希表中元素的频率，并将元素压入栈中；每次pop操作时，弹出栈顶元素，并更新哈希表中元素的频率；getMaxFrequency操作时，遍历哈希表找到出现频率最高的元素的频率。

#### 题目7：全O(1)的数据结构
- **问题描述**：设计一个数据结构，支持insert、delete和getRandom操作，所有操作的时间复杂度都为O(1)。
- **解决方案**：可以使用==数组和哈希表==结合的方式来实现，类似于题目3的解决方案。数组用于存储元素，哈希表用于存储元素和其在数组中的索引的映射关系。通过合理的设计和操作，可以保证insert、delete和getRandom操作的时间复杂度都为O(1)。

### 后续学习内容预告
- **【必备】、【扩展】、【挺难】视频**：后续将更新包含大量基础和高级数据结构原理详解的视频，帮助学习者更好地理解和掌握数据结构。
- **“好题解析”系列**：在原理详解系列结束后，将开始“好题解析”系列，讲解更多更难的算法、数据结构题目，进一步提升学习者的算法能力。

### 学习建议
- **持续关注与转发**：关注后续更新的视频和系列内容，以便及时学习和掌握更多的算法知识。
- **实践与应用**：在学习了这些数据结构设计题目后，要多进行实践，尝试自己实现这些数据结构，并在实际的编程项目中应用所学的知识，加深对数据结构的理解和掌握。
- **拓展学习**：对于本节未涉及的更难的数据结构设计题目，如前缀树、并查集、线段树等，可以在后续的学习中逐步深入学习，不断拓展自己的算法知识体系。