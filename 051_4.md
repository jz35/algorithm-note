# 第51课：二分答案法及相关题目

------

### 题目描述：

给定一个整数数组 `nums` 和一个整数 `k`，我们定义数对 `(a, b)` 为数组中任意两个元素 `a` 和 `b`，满足 `0 <= i < j < nums.length`。数对 `(a, b)` 的距离为 `|a - b|`，即 `a` 和 `b` 的绝对差值。

请返回所有数对距离中第 `k` 小的数对距离。

### 输入输出描述：

**输入：**

- 一个整数数组 `nums`，长度为 `n`，满足 `1 <= n <= 10^4`，`-10^6 <= nums[i] <= 10^6`。
- 一个整数 `k`，满足 `1 <= k <= n * (n - 1) / 2`。

**输出：**

- 返回所有数对距离中第 `k` 小的数对距离。

### 示例：

**示例 1：**

```
输入: nums = [1, 3, 1], k = 1
输出: 0
解释：所有数对距离为 [0, 2, 2]，第 1 小的数对距离是 0。
```

**示例 2：**

```
输入: nums = [1, 1, 1], k = 2
输出: 0
解释：所有数对距离为 [0, 0, 0]，第 2 小的数对距离是 0。
```

**示例 3：**

```
输入: nums = [1, 6, 1], k = 3
输出: 5
解释：所有数对距离为 [0, 5, 5]，第 3 小的数对距离是 5。
```

### 提示：

- 数组 `nums` 中的元素数量 `n` 可以达到 10^4，因此应考虑优化算法，避免使用 `O(n^2)` 的解决方案。

------

### 算法知识：

1. **排序：** 首先对数组进行排序，方便后续计算数对距离。
2. **二分查找：** 使用二分查找的方式确定数对距离的第 `k` 小值。查找范围从 0 到最大可能的距离（即 `max(nums) - min(nums)`）。
3. **双指针：** 在每次二分查找过程中，使用双指针方法来计算数对距离小于等于当前查找中点的数对数量。
4. **时间复杂度分析：** 排序数组的时间复杂度是 `O(n log n)`，每次二分查找的时间复杂度是 `O(n)`。因此总的时间复杂度是 `O(n log n + n log(max - min))`。

------

### 代码实现：

```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    // 时间复杂度 O(n * log(n) + log(max - min) * n)，额外空间复杂度 O(1)
    int smallestDistancePair(vector<int>& nums, int k) {
        int n = nums.size();
        // 排序数组
        sort(nums.begin(), nums.end());
        int ans = 0;
        // 二分查找数对距离的值
        for (int l = 0, r = nums[n - 1] - nums[0], m, cnt; l <= r;) {
            // m 为当前二分的中点，表示可能的数对距离
            m = l + ((r - l) >> 1);
            // 返回小于等于 m 的数对的数量
            cnt = countPairs(nums, m);
            if (cnt >= k) {
                ans = m;  // 如果数对的数量大于等于 k，更新答案
                r = m - 1;  // 缩小范围，尝试更小的数对距离
            } else {
                l = m + 1;  // 如果数对的数量小于 k，增加数对距离
            }
        }
        return ans;
    }

private:
    // 返回数组 arr 中，数对差值小于等于 limit 的数对数量
    int countPairs(const vector<int>& arr, int limit) {
        int ans = 0;
        int n = arr.size();
        // 使用双指针计算数对数量
        for (int l = 0, r = 0; l < n; l++) {
            // 尝试将 r 扩展到最大，保持差值小于等于 limit
            while (r + 1 < n && arr[r + 1] - arr[l] <= limit) {
                r++;
            }
            // 计算 [l, r] 范围内所有有效的数对
            ans += r - l;
        }
        return ans;
    }
};
```

------

### 复杂度分析：

- **时间复杂度：**
  - 排序 `nums` 需要 `O(n log n)`。
  - 每次二分查找时，计算数对数量的过程是 `O(n)`，由于二分查找范围是 `[0, max(nums) - min(nums)]`，最大次数为 `O(log(max - min))`。
  - 因此，总时间复杂度为 `O(n log n + n log(max - min))`。
- **空间复杂度：**
  - 使用常数级的额外空间，空间复杂度为 `O(1)`。