# 第66课：从递归入手一维动态规划

------

### 题目描述：

斐波那契数列（通常用 `F(n)` 表示）由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。

即：

- F(0) = 0
- F(1) = 1
- F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给定一个整数 `n`，请计算并返回 `F(n)`。

### 输入输出描述：

**输入：**

- 一个整数 `n` (`0 ≤ n ≤ 1000`)，表示要求斐波那契数列的第 `n` 项。

**输出：**

- 返回斐波那契数列的第 `n` 项 `F(n)`。

### 示例 1：

**输入：**

```cpp
2
```

**输出：**

```
1
```

**解释：** 斐波那契数列为 [0, 1, 1]，因此 `F(2) = 1`。

### 示例 2：

**输入：**

```cpp
3
```

**输出：**

```
2
```

**解释：** 斐波那契数列为 [0, 1, 1, 2]，因此 `F(3) = 2`。

### 示例 3：

**输入：**

```cpp
4
```

**输出：**

```
3
```

**解释：** 斐波那契数列为 [0, 1, 1, 2, 3]，因此 `F(4) = 3`。

### 约束：

- `0 ≤ n ≤ 1000`

------

### 算法分析：

#### 方法 1：递归法（暴力解法）

- **时间复杂度**：`O(2^n)`，因为每个状态都需要重复计算。
- **空间复杂度**：`O(n)`，递归调用栈的最大深度为 `n`。

```cpp
class Solution {
public:
    int fib1(int n) {
        return f1(n);
    }

    int f1(int i) {
        if (i == 0) {
            return 0;
        }
        if (i == 1) {
            return 1;
        }
        return f1(i - 1) + f1(i - 2);
    }
};
```

#### 方法 2：记忆化递归（自顶向下的动态规划）

- **时间复杂度**：`O(n)`，由于缓存了已经计算过的值，避免了重复计算。
- **空间复杂度**：`O(n)`，用于存储中间结果的数组。

```cpp
class Solution {
public:
    int fib2(int n) {
        vector<int> dp(n + 1, -1);
        return f2(n, dp);
    }

    int f2(int i, vector<int>& dp) {
        if (i == 0) {
            return 0;
        }
        if (i == 1) {
            return 1;
        }
        if (dp[i] != -1) {
            return dp[i];
        }
        int ans = f2(i - 1, dp) + f2(i - 2, dp);
        dp[i] = ans;
        return ans;
    }
};
```

#### 方法 3：动态规划（自底向上的动态规划）

- **时间复杂度**：`O(n)`，我们只需要遍历一次 `n`。
- **空间复杂度**：`O(n)`，存储从 `F(0)` 到 `F(n)` 的结果。

```cpp
class Solution {
public:
    int fib3(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        vector<int> dp(n + 1, 0);
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

#### 方法 4：空间优化的动态规划

- **时间复杂度**：`O(n)`，我们只需要遍历一次 `n`。
- **空间复杂度**：`O(1)`，我们只需要存储最后两个结果。

```cpp
class Solution {
public:
    int fib4(int n) {
        if (n == 0) return 0;
        if (n == 1) return 1;
        int lastLast = 0, last = 1;
        for (int i = 2; i <= n; i++) {
            int cur = lastLast + last;
            lastLast = last;
            last = cur;
        }
        return last;
    }
};
```

### 代码总结：

1. **递归法**：最直观的方式，但时间复杂度是指数级的，因此不适用于大数据。
2. **记忆化递归**：使用额外的数组存储已计算过的结果，从而避免重复计算，时间复杂度为 `O(n)`。
3. **动态规划**：通过从 `F(0)` 到 `F(n)` 的迭代计算，可以解决问题，时间复杂度为 `O(n)`。
4. **空间优化**：由于斐波那契数列只需要最后两个结果，因此可以将空间复杂度优化到 `O(1)`。

### 总结：

- 若要求计算较大的斐波那契数列项，建议使用 **动态规划** 或 **空间优化的动态规划** 方法，确保时间复杂度为 `O(n)`，并且使用最少的空间。