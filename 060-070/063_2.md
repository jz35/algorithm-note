# 第63课：双向广搜

### 算法题：牛牛的背包问题（世界冰球锦标赛）

#### 问题背景

牛牛准备参加学校组织的春游，他想在总体积不超过背包容量的情况下，将零食装入背包。给定每袋零食的体积和背包的容量，求解牛牛有多少种不同的装法。这个问题可以类比为世界冰球锦标赛的购票问题，即在预算内选择比赛的组合。

#### 输入输出格式

**输入**：

- 第一行包含两个正整数 n 和 w（1≤n≤30，1≤w≤2×109），分别表示零食的数量和背包的容量。
- 第二行包含 n 个正整数 v[i]（0≤v[i]≤109），表示每袋零食的体积。

**输出**：

- 输出一个正整数，表示牛牛一共有多少种零食放法。

#### 示例

**输入**：

```
5 1000
100 1500 500 500 1000
```

**输出**：

```
8
```

**解释**：

- 不选任何零食
- 选体积为 100 的零食
- 选第一袋体积为 500 的零食
- 选第二袋体积为 500 的零食
- 选体积为 100 的零食和第一袋体积为 500 的零食
- 选体积为 100 的零食和第二袋体积为 500 的零食
- 选两袋体积为 500 的零食
- 选体积为 1000 的零食

#### 解题思路

1. **问题分析**：
   - 这是一个典型的**子集和问题**，需要在给定的约束条件下（总体积不超过背包容量），计算所有可能的子集和。
   - 由于 n 的最大值为 30，直接暴力求解所有子集和的时间复杂度为 O(2n)，可能会超时。因此，需要优化算法。
2. **分治法**：
   - 将问题分为两部分：左半部分和右半部分。
   - 分别计算左半部分和右半部分的所有子集和。
   - 对左半部分和右半部分的子集和进行排序。
   - 使用双指针技巧，计算所有满足条件的子集和组合。
3. **具体步骤**：
   - **生成子集和**：
     - 使用递归函数 `f`，分别计算左半部分和右半部分的所有子集和。
   - **排序**：
     - 对左半部分和右半部分的子集和数组进行排序。
   - **双指针遍历**：
     - 从左半部分的最大子集和开始，使用双指针技巧，找到右半部分中与之相加不超过背包容量的最大子集和数量。

#### 代码实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 40; // 最大比赛数或零食数
const int MAXM = 1 << 20; // 最大子集数

long long arr[MAXN]; // 存储每场比赛的票价或每袋零食的体积
long long lsum[MAXM]; // 左半部分的子集和
long long rsum[MAXM]; // 右半部分的子集和

int n; // 比赛数或零食数
long long w; // 预算或背包容量

// 递归函数，用于生成从索引i到e的子集和，并存储在ans数组中
// 参数：
// i: 当前处理的起始索引
// e: 当前处理的结束索引
// s: 当前子集的和
// w: 预算或背包容量
// ans: 存储子集和的数组
// j: 当前ans数组的填充位置
int f(int i, int e, long long s, long long w, long long* ans, int j) {
    if (s > w) { // 如果当前子集和已经超过预算或背包容量，直接返回
        return j;
    }
    // 如果已经处理完当前范围的所有元素
    if (i == e) {
        ans[j++] = s; // 将当前子集和存入ans数组
    } else {
        // 不选择当前元素arr[i]
        j = f(i + 1, e, s, w, ans, j);
        // 选择当前元素arr[i]
        j = f(i + 1, e, s + arr[i], w, ans, j);
    }
    return j; // 返回ans数组的填充位置
}

// 主计算函数
long long compute() {
    int lsize = f(0, n >> 1, 0, w, lsum, 0); // 计算左半部分的子集和
    int rsize = f(n >> 1, n, 0, w, rsum, 0); // 计算右半部分的子集和
    sort(lsum, lsum + lsize); // 对左半部分的子集和进行排序
    sort(rsum, rsum + rsize); // 对右半部分的子集和进行排序
    long long ans = 0; // 初始化答案
    for (int i = lsize - 1, j = 0; i >= 0; i--) { // 从左半部分的最大子集和开始遍历
        while (j < rsize && lsum[i] + rsum[j] <= w) { // 寻找右半部分中与当前左半部分子集和相加不超过预算的最大子集和
            j++;
        }
        ans += j; // 将符合条件的右半部分子集和数量加到答案中
    }
    return ans; // 返回最终答案
}

int main() {
    // 输入处理
    cin >> n >> w; // 输入比赛数或零食数和预算或背包容量
    for (int i = 0; i < n; i++) {
        cin >> arr[i]; // 输入每场比赛的票价或每袋零食的体积
    }
    // 输出结果
    cout << compute() << endl; // 调用计算函数并输出结果
    return 0;
}
```

### 代码说明

1. **数组定义**：
   - `arr` 存储每场比赛的票价或每袋零食的体积。
   - `lsum` 和 `rsum` 分别存储左半部分和右半部分的子集和。
2. **递归函数 `f`**：
   - 递归生成从索引 `i` 到 `e` 的所有子集和，并存储在 `ans` 数组中。
   - 通过递归调用自身，分别考虑选择和不选择当前元素的情况。
3. **主计算函数 `compute`**：
   - 分别计算左半部分和右半部分的子集和。
   - 对子集和数组进行排序。
   - 使用双指针技巧，从左半部分的最大子集和开始，寻找右半部分中与之相加不超过预算的最大子集和数量。
4. **输入输出**：
   - 使用标准输入输出流进行输入和输出。

### 时间复杂度

- 生成子集和的时间复杂度为 O(2n/2)，排序的时间复杂度为 O(2n/2log2n/2)，双指针遍历的时间复杂度为 O(2n/2)。
- 总时间复杂度为 O(2n/2log2n/2)，在 n≤40 的情况下是可以接受的。

### 空间复杂度

- 存储子集和的数组大小为 O(2n/2)，因此空间复杂度为 O(2n/2)。