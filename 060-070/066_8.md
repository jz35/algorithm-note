# 第66课：从递归入手一维动态规划

------

### 题目描述：

给定一个字符串 `s`，计算其不同的非空子序列的个数。由于结果可能很大，答案需要对 `1000000007` 取模。

**子序列** 是通过从字符串中删除某些字符（也可以不删除字符）并保持剩余字符的相对位置来得到的新字符串。

例如，"ace" 是 "abcde" 的一个子序列，但 "aec" 不是。

### 输入输出描述：

**输入：**

- 一个字符串 `s`，长度为 `n` (`1 ≤ n ≤ 1000`)，字符串只包含小写字母。

**输出：**

- 返回 `s` 的不同非空子序列的个数，对 `1000000007` 取模。

### 示例 1：

**输入：**

```cpp
"abc"
```

**输出：**

```
7
```

**解释：** 所有不同的子序列是：`"a"`, `"b"`, `"c"`, `"ab"`, `"ac"`, `"bc"`, `"abc"`。

### 示例 2：

**输入：**

```cpp
"aaa"
```

**输出：**

```
6
```

**解释：** 所有不同的子序列是：`"a"`, `"aa"`, `"aaa"`。

### 约束：

- `1 ≤ s.length ≤ 1000`
- `s[i]` 是小写字母。

------

### 算法分析：

#### 动态规划思路：

- 使用一个数组 `cnt[26]` 来记录每个字符之前出现的子序列个数。
- 对于每个字符，我们可以通过上一个状态（即当前字符之前的子序列个数）来更新当前字符的新子序列个数。
- `all` 记录当前所有子序列的总数，`newAdd` 记录当前字符新增的子序列数量。

#### 状态转移：

- 对于每个字符 `x`，新增的子序列数量是由当前字符本身新增的子序列数量和该字符之前出现的相同字符的子序列数量相加得到的。
- 为了避免重复计数，我们需要从 `all` 中减去之前已经包含该字符的子序列数量。

#### 计算公式：

- `newAdd = (all - cnt[x - 'a'] + mod) % mod`：当前字符 `x` 新增的子序列数量。
- `cnt[x - 'a'] = (cnt[x - 'a'] + newAdd) % mod`：更新当前字符的子序列数量。
- `all = (all + newAdd) % mod`：更新所有子序列的总数。

### 时间复杂度：

- **时间复杂度**：`O(n)`，其中 `n` 是字符串 `s` 的长度。我们遍历字符串一次，并在每次遍历时进行常数时间的计算。
- **空间复杂度**：`O(1)`，我们只使用了一个大小为 26 的数组来记录每个字符的子序列数量。

### 代码实现：

```cpp
class Solution {
public:
    int distinctSubseqII(string s) {
        int mod = 1000000007;
        int n = s.size();
        vector<int> cnt(26, 0);  // 记录每个字符出现的次数
        int all = 1, newAdd;

        for (char x : s) {
            newAdd = (all - cnt[x - 'a'] + mod) % mod;  // 新增的子序列数量
            cnt[x - 'a'] = (cnt[x - 'a'] + newAdd) % mod;  // 更新当前字符的子序列数量
            all = (all + newAdd) % mod;  // 更新所有子序列的总数
        }

        return (all - 1 + mod) % mod;  // 去掉空子序列
    }
};
```

### 过程分析：

1. **字符转换**：我们遍历字符串，将每个字符转化为数字 `0-25`，以便使用数组 `cnt` 来存储对应字符的子序列数量。
2. **动态规划**：使用变量 `all` 来记录所有子序列的总数。每遇到一个字符，我们计算它新增的子序列数量，并更新所有子序列的总数。
3. **去空子序列**：最终，返回 `all - 1`，因为我们不需要计算空子序列。

### 结论：

- 通过动态规划，计算每个字符添加的子序列数量，并用数组 `cnt` 来避免重复计算。最终得到所有不同非空子序列的个数。