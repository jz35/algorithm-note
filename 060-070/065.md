# 第65课：A*算法、Floyd 算法、Floyd 算法、Bellman-Ford + SPFA 优化

### A* 算法

- **基本概念**：指定源点和目标点，求源点到目标点的最短距离。在Dijkstra算法的基础上增加了当前点到终点的预估函数，根据“从源点出发到达当前点的距离+当前点到终点的预估距离”在堆中进行排序，其余细节与Dijkstra算法一致。
- **预估函数要求**：预估距离必须小于等于当前点到终点的真实最短距离。合适的吸引力可以提升算法速度，但吸引力过强会出现错误。在保证预估距离小于等于真实最短距离的前提下，尽量接近真实最短距离，可实现功能正确且速度最快。
- **常见预估终点距离**：曼哈顿距离、欧式距离、对角线距离。

### Floyd 算法

- **基本概念**：用于求图中任意两点之间的最短距离。
- **时间复杂度**：O(n³)。
- **空间复杂度**：O(n²)。
- **适用范围**：适用于任何图，无论有向无向、边权正负，但不能有负环，以保证最短路存在。
- **实现过程**：用`distance[i][j]`表示i和j之间的最短距离，通过`distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])`来更新最短距离，需先枚举跳板k。

### Floyd 算法

- **基本概念**：解决存在负权边但无负环的图的单源最短路问题。
- **松弛操作**：假设源点为A，从A到任意点F的最短距离为`distance[F]`，从点P出发某条边去往点S，边权为W，若`distance[P] + W < distance[S]`，则通过该边可使`distance[S]`变小，即对该边进行了松弛操作。
- **算法过程**：每轮考察每条边，尝试进行松弛操作，若干点的`distance`会变小，当某轮不再有松弛操作出现时，算法停止。
- **时间复杂度**：假设点的数量为N，边的数量为M，每轮时间复杂度O(M)，最短路存在时，松弛轮数最多为n - 1，故总时间复杂度为O(M*N)。
- **判断负环**：若从某点出发存在最短路，则松弛轮数必然小于等于n - 1；若从该点出发能到达负环，则松弛操作会无休止进行。若在第n轮仍有松弛操作，则说明从该点出发能到达负环。

### Bellman-Ford + SPFA 优化

- **优化思路**：每轮考察所有边以判断能否进行松弛操作是不必要的，只有上一轮被松弛过的节点所连接的边，才可能引起下一轮的松弛操作。因此，用队列维护“这一轮哪些节点的distance变小了”，下一轮只需考察这些点的所有边，看是否有松弛操作。
- **时间复杂度**：仍为O(n*m)，但常数时间得到优化，在大多数情况下跑得更快，适用于小图。
- **适用场景**：
  - 适用于小图。
  - 解决有负边但无负环的图的单源最短路径问题。
  - 可判断从某点出发是否能遇到负环，若想判断整张有向图是否有负环，需设置虚拟源点。
  - 在并行计算时有优势，因每轮多点判断松弛操作相互独立，可多线程处理。
- **其他用途**：可用于解决“费用流”问题，但也可被Primal-Dual原始对偶算法替代，该内容会在后续课程中讲述。

### 练习题目

- **A\* 算法**：题目1，提供A*算法模板，与Dijkstra算法对比，采用对数器验证。
- **Floyd 算法**：题目2，提供Floyd算法模板，测试链接为[洛谷P2910](https://www.luogu.com.cn/problem/P2910)。
- **Bellman-Ford 算法**：题目3，应用题目在Leetcode，测试链接为[Leetcode cheapest-flights-within-k-stops](https://leetcode.cn/problems/cheapest-flights-within-k-stops/)。
- **Bellman-Ford + SPFA 优化**：题目4，给定有向图，判断是否存在从顶点1出发能到达的负环，测试链接为[洛谷P3385](https://www.luogu.com.cn/problem/P3385)。