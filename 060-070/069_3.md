# 第69课：从递归入手三维动态规划

### 算法题：骑士在棋盘上的概率

#### 题目描述：

在一个 
$$
n \times n
$$
的国际象棋棋盘上，一个骑士从单元格 (row,col)(row, col) 开始，并尝试进行 kk 次移动。骑士可以从当前位置进行 8 种可能的移动，每次移动时，骑士在基本方向上会走两个单元格，然后在正交方向上走一个单元格。每次骑士会随机选择一种移动方式。骑士继续移动，直到它走了 kk 步或离开了棋盘。

请你返回骑士在棋盘停止移动后仍留在棋盘上的概率。

**注意：**

- 行和列从 0 开始，所以左上单元格是 (0,0)(0,0)，右下单元格是 (n−1,n−1)(n-1, n-1)。

#### 输入：

- 整数 nn 表示棋盘的大小。
- 整数 kk 表示骑士要走的步数。
- 整数 rowrow 表示骑士起始位置的行索引。
- 整数 colcol 表示骑士起始位置的列索引。

#### 输出：

- 返回骑士在棋盘停止移动后仍留在棋盘上的概率，保留 5 位小数。

#### 示例：

**输入 1:**

```plaintext
n = 3, k = 2, row = 0, col = 0
```

**输出 1:**

```plaintext
0.06250
```

**输入 2:**

```plaintext
n = 8, k = 30, row = 6, col = 4
```

**输出 2:**

```plaintext
0.00000
```

#### 提示：

- 1≤n≤251 \leq n \leq 25
- 0≤k≤1000 \leq k \leq 100
- 0≤row,col<n0 \leq row, col < n

#### 解题思路：

1. **状态定义**：

   - 使用三维动态规划数组 `dp[i][j][k]`，表示从位置 (i,j)(i, j) 开始，剩余 kk 步时，骑士仍然在棋盘上的概率。

2. **递归转移**：

   - 从当前棋盘位置 

     (i,j)(i, j)

      出发，骑士可以选择 8 种可能的移动方式，分别是：

     - 上 2，右 1
     - 上 1，右 2
     - 下 1，右 2
     - 下 2，右 1
     - 下 2，左 1
     - 下 1，左 2
     - 上 1，左 2
     - 上 2，左 1

   - 对于每种移动，递归计算剩余步数时骑士停留在棋盘上的概率。

3. **递归终止条件**：

   - 如果骑士走出了棋盘，即坐标 (i,j)(i, j) 超出棋盘边界，则返回 0。
   - 如果剩余步数 kk 为 0，表示已完成所有步数，此时返回 1。

4. **记忆化搜索**：

   - 为了避免重复计算，使用 `dp` 数组来缓存每次计算的结果。

#### 代码实现：

```cpp
class Solution {
public:
    double knightProbability(int n, int k, int row, int column) {
        vector<vector<vector<double>>> dp(n, vector<vector<double>>(n, vector<double>(k + 1, -1)));
        return f(n, row, column, k, dp);
    }
    
    double f(int n, int i, int j, int k, vector<vector<vector<double>>>& dp) {
        // 如果当前位置超出棋盘，返回 0
        if (i < 0 || i >= n || j < 0 || j >= n) {
            return 0;
        }
        
        // 如果没有剩余步数，则骑士还在棋盘上，返回 1
        if (k == 0) {
            return 1;
        }
        
        // 如果已经计算过，直接返回缓存的结果
        if (dp[i][j][k] != -1) {
            return dp[i][j][k];
        }
        
        // 计算所有可能的移动方式，累加概率
        double ans = 0;
        ans += (f(n, i - 2, j + 1, k - 1, dp) / 8);
        ans += (f(n, i - 1, j + 2, k - 1, dp) / 8);
        ans += (f(n, i + 1, j + 2, k - 1, dp) / 8);
        ans += (f(n, i + 2, j + 1, k - 1, dp) / 8);
        ans += (f(n, i + 2, j - 1, k - 1, dp) / 8);
        ans += (f(n, i + 1, j - 2, k - 1, dp) / 8);
        ans += (f(n, i - 1, j - 2, k - 1, dp) / 8);
        ans += (f(n, i - 2, j - 1, k - 1, dp) / 8);
        
        // 缓存结果
        dp[i][j][k] = ans;
        return ans;
    }
};
```

#### 复杂度分析：

- **时间复杂度**：
  $$
  O(n^2 \times k)
  $$
  ，由于存在 8 种移动方式，且每次移动都会递归计算，因此状态数为 n×n×kn \times n \times k。

- **空间复杂度**：O(n2×k)O(n^2 \times k)，需要一个三维数组存储每个状态的计算结果。

