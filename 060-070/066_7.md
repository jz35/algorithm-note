# 第66课：从递归入手一维动态规划

### 题目描述：

给定一个字符串 `s`，定义一个字符串 `base` 为 `"abcdefghijklmnopqrstuvwxyz"` 的无限循环字符串。我们要求计算 `s` 中有多少不同的非空子串也出现在 `base` 中。字符串 `base` 在无限循环时，能够表示任意长度的环绕字符串。

### 输入输出描述：

**输入：**

- 一个字符串 `s`，长度为 `n` (`1 ≤ n ≤ 1000`)，该字符串由小写字母组成。

**输出：**

- 返回 `s` 中不同的、有效的非空子串的个数。

### 示例 1：

**输入：**

```cpp
"zaba"
```

**输出：**

```
6
```

**解释：** 符合条件的有效子串是：

- `"z"`, `"a"`, `"b"`, `"zab"`, `"aba"`, `"zaba"`

### 示例 2：

**输入：**

```cpp
"cacb"
```

**输出：**

```
4
```

**解释：** 符合条件的有效子串是：

- `"c"`, `"a"`, `"b"`, `"ca"`

### 算法分析：

1. **状态定义**：
   - `dp[i]` 表示以字符 `i`（即 `a` + i）结尾的最大有效子串长度。
2. **递推关系**：
   - 若 `s[i]` 和 `s[i-1]` 是连续的字符（即 `s[i-1]` 和 `s[i]` 之间的 ASCII 值差为 1，或者 `s[i-1]` 是 `'z'` 且 `s[i]` 是 `'a'`），则可以延长子串的长度。
   - 否则，从当前位置开始一个新的子串。
3. **最终结果**：
   - 将 `dp` 数组中的值加起来，即为最终的结果。每个 `dp[i]` 对应以字符 `i` 为结尾的子串的最大长度。

### 时间复杂度：

- **时间复杂度**：`O(n)`，其中 `n` 是字符串 `s` 的长度。我们遍历字符串一次，且每次更新 `dp` 数组中的值所需时间是常数级别。
- **空间复杂度**：`O(1)`（忽略输入字符串的空间消耗），我们只使用了一个 `dp` 数组，长度为 26，存储每个字符结尾的最大子串长度。

### 代码实现：

```cpp
class Solution {
public:
    int findSubstringInWraproundString(string s) {
        int n = s.size();
        vector<int> dp(26, 0); // dp[i]记录以字符 'a' + i 为结尾的最长有效子串长度
        vector<int> str(n);

        // 将字符串中的字符转为数字 0 ~ 25 ('a' -> 0, ..., 'z' -> 25)
        for (int i = 0; i < n; i++) {
            str[i] = s[i] - 'a';
        }

        // 遍历字符串，计算每个字符结尾的最大子串长度
        for (int i = 0, len = 1; i < n; i++) {
            int cur = str[i];
            int pre = (i == 0) ? -1 : str[i - 1]; // 防止越界

            // 判断是否是环绕连续的
            if ((pre == 25 && cur == 0) || pre + 1 == cur) {
                len++;  // 连续，则长度加1
            } else {
                len = 1;  // 不连续，重新计算长度
            }

            // dp[cur]表示以s[i]为结尾的最大子串长度
            dp[cur] = max(dp[cur], len);
        }

        // 统计所有不同的子串
        int ans = 0;
        for (int i = 0; i < 26; i++) {
            ans += dp[i]; // 每个字符结尾的最大子串长度
        }

        return ans;
    }
};
```

### 过程分析：

1. **字符串转化**：
   - 我们将字符串 `s` 中的每个字符转化为对应的数字（`a -> 0, b -> 1, ..., z -> 25`），并存储在 `str` 数组中。
2. **计算最大子串长度**：
   - 使用变量 `len` 来记录以当前字符为结尾的最长有效子串的长度。
   - 如果当前字符和前一个字符是环绕的（即连续或环绕从 `'z'` 到 `'a'`），则延长当前子串的长度；否则，重新开始一个新的子串。
3. **累加结果**：
   - 最后，遍历 `dp` 数组并累加所有不同字符结尾的有效子串长度，得到最终的答案。

### 结论：

- 这道题考察了如何使用动态规划来求解字符串中有效的环绕子串个数。通过更新 `dp` 数组来存储每个字符结尾的子串长度，最终将所有长度相加得到最终结果。

