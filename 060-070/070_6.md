# 第70课：子数组最大累加和问题与扩展-上

### **算法题：子矩阵最大累加和问题（Maximum Submatrix Sum）**

#### **题目描述**

给定一个二维数组 `grid`，找到其中 **子矩阵的最大累加和**，并返回该子矩阵的 **左上角和右下角坐标**。
 如果存在多个子矩阵拥有相同的最大累加和，则返回任意一个都可以。

------

#### **输入描述**

- `grid`：二维整数数组，大小为 `n × m`（`1 ≤ n, m ≤ 200`）。

------

#### **输出描述**

- 返回一个包含 `4` 个整数的数组 `[a, b, c, d]`，表示最大累加和子矩阵的左上角 `(a, b)` 和右下角 `(c, d)`。

------

#### **示例**

##### **示例 1**

**输入**

```
grid = [
    [-1,  0,  1],
    [ 2, -3,  4],
    [-5,  6,  7]
]
```

**输出**

```
[1, 2, 2, 2]
```

**解释** 最大累加和子矩阵为：

```
[
    [4],
    [7]
]
```

左上角坐标为 `(1,2)`，右下角坐标为 `(2,2)`。

------

#### **解题思路**

##### **1. 压缩行降维**

我们使用 **Kadane's Algorithm（最大子数组和算法）** 计算每一列的前缀和，将 `n × m` 矩阵压缩为 `m` 长度的数组，然后求最大子数组和。

##### **2. 遍历所有可能的上下边界**

- 枚举上边界 `up` 和下边界 `down`，将所有介于 `up` 和 `down` 之间的行压缩到一维数组 `nums`。
- 在 `nums` 上求 **最大子数组和**，并记录对应的左右边界。

##### **3. 使用Kadane算法求最大子数组和**

- 维护 `pre` 记录当前子数组和，如果 `pre < 0`，重新开始计算。
- 记录最大累加和 `maxSum` 以及对应的子矩阵坐标 `(a, b, c, d)`。

##### **4. 时间复杂度分析**

- **外层 `O(n^2)`**：遍历所有可能的上下边界。
- **内层 `O(m)`**：Kadane算法求最大子数组和。
- **总复杂度**：`O(n^2 * m)`，对于 `n, m ≤ 200` 仍然可行。

------

### **C++ 代码实现**

```cpp
#include <vector>
#include <climits>
#include <algorithm>

using namespace std;

class Solution {
public:
    vector<int> getMaxMatrix(vector<vector<int>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        
        int maxSum = INT_MIN;  // 记录最大累加和
        int a = 0, b = 0, c = 0, d = 0;  // 记录最大子矩阵的坐标
        
        vector<int> nums(m, 0);  // 存储压缩后的列和
        
        // 遍历所有可能的上边界
        for (int up = 0; up < n; up++) {
            fill(nums.begin(), nums.end(), 0);  // 重置列和
            
            // 遍历所有可能的下边界
            for (int down = up; down < n; down++) {
                
                // 使用 Kadane's Algorithm 求最大子数组和
                int pre = INT_MIN;  // 记录当前子数组和
                int left = 0;  // 记录当前子数组的左边界
                
                for (int r = 0; r < m; r++) {
                    nums[r] += grid[down][r];  // 压缩列和
                    
                    // Kadane's 算法：寻找最大子数组和
                    if (pre >= 0) {
                        pre += nums[r];
                    } else {
                        pre = nums[r];
                        left = r;  // 重新设定左边界
                    }
                    
                    // 记录最大累加和及对应坐标
                    if (pre > maxSum) {
                        maxSum = pre;
                        a = up;    // 上边界
                        b = left;  // 左边界
                        c = down;  // 下边界
                        d = r;     // 右边界
                    }
                }
            }
        }
        
        return {a, b, c, d};  // 返回最大子矩阵的坐标
    }
};
```

------

### **复杂度分析**

- **外层 `O(n^2)`**：遍历所有可能的上、下边界。

- **内层 `O(m)`**：Kadane's 算法找最大子数组和。

- 总复杂度 `O(n^2 * m)`

  ：

  - **对于 `n, m ≤ 200`**，最坏情况 `O(200^3) ≈ 8 × 10^6`，仍可接受。

------

### **总结**

✅ **使用 `O(n^2 \* m)` 的最优解求解子矩阵最大累加和**。
 ✅ **利用 Kadane's 算法在 `O(m)` 时间内找到最大子数组和**。
 ✅ **记录子矩阵的左上角 `(a, b)` 和右下角 `(c, d)` 作为最终答案**。

✨ **代码简单高效，可直接应用于矩阵最大和问题！** 🚀