# 第66课：从递归入手一维动态规划

### 题目：第 n 个丑数

#### 题目描述
给你一个整数 `n`，请你找出并返回第 `n` 个 **丑数**。  
**丑数** 是只包含质因数 `2`、`3` 或 `5` 的正整数。

#### 示例
**输入**: `n = 10`  
**输出**: `12`  
**解释**: 前 10 个丑数是 `[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]`，第 10 个丑数是 `12`。

#### 解题思路
1. **动态规划**：
   - 使用一个数组 `dp` 来存储前 `n` 个丑数。
   - `dp[1] = 1`，因为第一个丑数是 `1`。
   - 对于每个位置 `i`，`dp[i]` 是 `dp[i2] * 2`、`dp[i3] * 3` 和 `dp[i5] * 5` 中的最小值。
   - 如果 `dp[i]` 等于某个值（例如 `dp[i2] * 2`），则对应的指针（`i2`）需要递增，以避免重复计算。

2. **指针优化**：
   - 使用三个指针 `i2`、`i3` 和 `i5`，分别表示当前乘以 `2`、`3` 和 `5` 的位置。
   - 每次选择最小的值作为下一个丑数，并更新对应的指针。

#### 代码实现
```cpp
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> dp(n + 1); // 存储前 n 个丑数
        dp[1] = 1; // 第一个丑数是 1
        int i2 = 1, i3 = 1, i5 = 1; // 三个指针
        for (int i = 2; i <= n; ++i) {
            int a = dp[i2] * 2; // 当前 i2 指向的丑数乘以 2
            int b = dp[i3] * 3; // 当前 i3 指向的丑数乘以 3
            int c = dp[i5] * 5; // 当前 i5 指向的丑数乘以 5
            int cur = min(min(a, b), c); // 取最小值作为下一个丑数
            if (cur == a) ++i2; // 如果选择了 a，则 i2 指针后移
            if (cur == b) ++i3; // 如果选择了 b，则 i3 指针后移
            if (cur == c) ++i5; // 如果选择了 c，则 i5 指针后移
            dp[i] = cur; // 将当前丑数存入 dp 数组
        }
        return dp[n]; // 返回第 n 个丑数
    }
};
```

#### 复杂度分析
- **时间复杂度**：`O(n)`，其中 `n` 是第 `n` 个丑数的位置。我们只需要遍历一次数组即可。
- **空间复杂度**：`O(n)`，用于存储前 `n` 个丑数的数组。

#### 测试用例
```cpp
int main() {
    Solution solution;
    cout << solution.nthUglyNumber(10) << endl; // 输出: 12
    cout << solution.nthUglyNumber(1) << endl;  // 输出: 1
    cout << solution.nthUglyNumber(20) << endl; // 输出: 36
    return 0;
}
```

#### 总结
本题通过动态规划和指针优化的方法，高效地计算第 `n` 个丑数。关键在于维护三个指针，分别指向当前乘以 `2`、`3` 和 `5` 的位置，避免重复计算。

