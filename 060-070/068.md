# 第68课：二维动态规划题目

### 一、二维动态规划问题概述

- **学习方法**：本节课不再从递归入手，而是直接从动态规划的定义入手，来见识更多二维动态规划问题。这要求我们对动态规划的基本概念和方法有更深入的理解，能够直接根据问题的描述来设计动态规划的解决方案。
- **重要性**：二维动态规划问题非常多，不仅在本节课涉及，在整个系列课程中都会大量出现。后续课程还会讲到背包dp、区间dp、状压dp等，这些内容依然包含大量二维动态规划问题。因此，掌握二维动态规划对于深入学习算法非常重要。

### 二、典型题目分析

- **题目1：不同的子序列**
  - **问题描述**：给定两个字符串s和t，统计在s的所有子序列中，有多少个子序列等于t。
  - **解题思路**：这是一个二维动态规划问题。可以定义一个二维动态规划表dp，其中dp[i][j]表示s的前i个字符中包含t的前j个字符的子序列个数。状态转移方程为：如果s[i - 1] == t[j - 1]，则dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]；否则，dp[i][j] = dp[i - 1][j]。初始状态为dp[i][0] = 1，表示空字符串t在s的任何前缀中都出现1次。
- **题目2：编辑距离**
  - **问题描述**：给定两个单词word1和word2，返回将word1转换成word2所使用的最少代价。可以对一个单词进行插入、删除、替换三种操作，分别有对应的代价a、b、c。
  - **解题思路**：这是一个经典的二维动态规划问题。可以定义一个二维动态规划表dp，其中dp[i][j]表示word1的前i个字符转换成word2的前j个字符的最少代价。状态转移方程为：如果word1[i - 1] == word2[j - 1]，则dp[i][j] = dp[i - 1][j - 1]；否则，dp[i][j] = min(dp[i - 1][j] + b, dp[i][j - 1] + a, dp[i - 1][j - 1] + c)。初始状态为dp[i][0] = i * bdp和[0][j] = j * a。
- **题目3：交错字符串**
  - **问题描述**：给定三个字符串s1、s2、s3，验证s3是否由s1和s2交错组成。
  - **解题思路**：这是一个二维动态规划问题。可以定义一个二维动态规划表dp，其中dp[i][j]表示s1的前i个字符和s2的前j个字符能否交错组成s3的前i + j个字符。状态转移方程为：如果s3[i + j - 1] == s1[i - 1]，则dp[i][j] = dp[i - 1][j]；如果s3[i + j - 1] == s2[j - 1]，则dp[i][j] = dp[i][j - 1]；如果两个条件都满足，则dp[i][j] = dp[i - 1][j] || dp[i][j - 1]。初始状态为dp[0][0] = true。
- **题目4：有效涂色问题**
  - **问题描述**：给定n、m两个参数，一共有n个格子，每个格子可以涂上一种颜色，颜色在m种里选。当涂满n个格子，并且m种颜色都使用了，叫一种有效方法。求一共有多少种有效的涂色方法。结果比较大请%1000000007之后返回。
  - **解题思路**：这是一个组合数学和动态规划相结合的问题。可以定义一个二维动态规划表dp，其中dp[i][j]表示涂了i个格子，用了j种颜色的有效涂色方法数。状态转移方程需要根据组合数学的知识来推导，考虑新涂一个格子时颜色的选择情况。
- **题目5：删除至少几个字符可以变成另一个字符串的子串**
  - **问题描述**：给定两个字符串s1和s2，返回s1至少删除多少字符可以成为s2的子串。
  - **解题思路**：这是一个二维动态规划问题。可以定义一个二维动态规划表dp，其中dp[i][j]表示s1的前i个字符删除若干字符后能否成为s2的前j个字符的子串，以及对应的最少删除字符数。状态转移方程需要根据s1和s2的字符匹配情况来确定。