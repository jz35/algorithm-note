# 第35课：数据结构基础设计

## `unordered_map` 和 `map`

##### `unordered_map` 和 `map` 是 C++ 标准库中的两种常用关联容器，它们的主要区别在于**底层实现**、**操作效率**、**键的存储顺序**以及**使用场景**。

------

### **1. 底层实现**

- **`unordered_map`**
  - 基于 **哈希表** 实现。
  - 元素的键值对（key-value）没有固定的顺序。
  - 使用哈希函数计算键的位置。
- **`map`**
  - 基于 **红黑树**（自平衡二叉搜索树）实现。
  - 元素按键的**升序**或指定的排序规则存储。

------

### **2. 操作效率**

- **时间复杂度**

  - `unordered_map`:
  - 查找、插入、删除的平均时间复杂度为 O(1)O(1)。
    - 最坏情况下（哈希冲突严重时）为 O(n)O(n)。

  - `map`:
  
    - 查找、插入、删除的时间复杂度为 O(log⁡n)O(\log n)。
  
- **性能对比**

  - 如果键分布均匀，`unordered_map` 的性能通常优于 `map`。
  - 如果需要排序或按序遍历，`map` 是唯一选择。

------

### **3. 元素存储顺序**

- **`unordered_map`**:
  - 元素顺序是不可预测的，因为它依赖于哈希函数。
  - 不支持按照键的顺序遍历。
- **`map`**:
  - 元素按键的**升序**或用户自定义的排序规则存储。
  - 支持按照键的顺序遍历。

------

### **4. 内存使用**

- `unordered_map`:
  - 通常比 `map` 使用更多内存，因为它需要存储额外的哈希表结构和处理哈希冲突的数据。
  
- `map`:
- 使用较少的内存，但由于维护红黑树结构，插入和删除操作会涉及额外的旋转操作。

------

### **5. 使用场景**

- **`unordered_map`**:
  - 当需要快速查找或插入元素时（且不关心键的顺序）。
  - 如：缓存系统（LRU）、计数器、哈希表等。
- **`map`**:
  - 当需要按照键的顺序存储元素，或需要按序遍历时。
  - 如：有序字典、区间问题等。

------

### **6. 示例代码**

```cpp
#include <iostream>
#include <map>
#include <unordered_map>
using namespace std;

int main() {
    // map 示例
    map<int, string> orderedMap;
    orderedMap[2] = "two";
    orderedMap[1] = "one";
    orderedMap[3] = "three";

    cout << "map (ordered): ";
    for (auto& [key, value] : orderedMap) {
        cout << key << ":" << value << " ";
    }
    cout << endl;

    // unordered_map 示例
    unordered_map<int, string> unorderedMap;
    unorderedMap[2] = "two";
    unorderedMap[1] = "one";
    unorderedMap[3] = "three";

    cout << "unordered_map: ";
    for (auto& [key, value] : unorderedMap) {
        cout << key << ":" << value << " ";
    }
    cout << endl;

    return 0;
}
```

**输出示例**：

```
map (ordered): 1:one 2:two 3:three 
unordered_map: 3:three 1:one 2:two 
```

------

### **总结**

| 特性           | `unordered_map`              | `map`               |
| -------------- | ---------------------------- | ------------------- |
| **底层实现**   | 哈希表                       | 红黑树              |
| **时间复杂度** | O(1)O(1) 平均，O(n)O(n) 最坏 | O(log⁡n)O(\log n)    |
| **键的顺序**   | 无序                         | 有序（升序/自定义） |
| **内存占用**   | 较高                         | 较低                |
| **使用场景**   | 快速查找、不关心顺序         | 需要排序或按序遍历  |

根据具体需求选择适合的容器，可以在性能和功能之间找到最佳平衡。



## `unordered_set` 和 `set`

##### `unordered_set` 和 `set` 是 C++ 标准模板库 (STL) 中的容器，它们都用于存储唯一的元素，但在底层实现和性能特性上有显著的区别：

### 1. 底层实现

- **`unordered_set`**:
  - 基于 **哈希表** 实现。
  - 元素的存储顺序是无序的，依赖于哈希函数。
  - 提供常数时间复杂度 O(1)O(1) 的插入、删除和查找操作（平均情况下，最坏情况下可能退化为 O(n)O(n)，取决于哈希函数质量和冲突处理机制）。
- **`set`**:
  - 基于 **红黑树（平衡二叉搜索树）** 实现。
  - 元素按 **排序顺序**（通常是从小到大）存储。
  - 插入、删除和查找操作的时间复杂度是 O(log⁡n)O(\log n)。

### 2. 元素顺序

- **`unordered_set`**:
  - 元素是无序存储的，没有固定的顺序。
  - 不能通过遍历访问时保证特定顺序。
- **`set`**:
  - 元素按升序（或自定义比较规则）存储。
  - 可以直接进行顺序遍历（如从小到大或从大到小）。

### 3. 功能特性

- **`unordered_set`**:
  - 提供高效的哈希存储，适用于频繁的插入、删除和查找操作。
  - 不支持范围查询（如找到大于某个值的所有元素）。
- **`set`**:
  - 支持顺序操作，例如范围查询（`lower_bound`、`upper_bound` 等）。
  - 可用于需要保持元素顺序的场景。

### 4. 内存使用

- **`unordered_set`**:
  - 由于哈希表的开销，通常比 `set` 使用更多的内存。
  - 空间利用率较低。
- **`set`**:
  - 使用平衡二叉树，内存利用率较高。

### 5. 适用场景

- **`unordered_set`**:
  - 适用于需要高效插入、删除、查找，且对元素顺序无要求的场景。
  - 例如：查找唯一值是否存在。
- **`set`**:
  - 适用于需要顺序访问或范围查询的场景。
  - 例如：获取一定范围内的元素或对元素排序。

### 总结对比表

| 特性         | `unordered_set`              | `set`              |
| ------------ | ---------------------------- | ------------------ |
| 底层实现     | 哈希表                       | 红黑树             |
| 时间复杂度   | O(1)O(1) 平均，最坏 O(n)O(n) | O(log⁡n)O(\log n)   |
| 元素顺序     | 无序                         | 有序               |
| 内存使用     | 较高                         | 较低               |
| 顺序操作支持 | 不支持                       | 支持               |
| 适用场景     | 快速查找和操作               | 顺序访问或范围查询 |

### 使用建议

- 如果只需要高效地判断元素是否存在，使用 **`unordered_set`**。
- 如果需要保持元素的排序或者进行范围查询，使用 **`set`**。



##### 优先队列通常使用堆来实现，是因为堆具备以下几个优点，使其非常适合用于优先队列的实现：

1. **高效的插入和删除操作**：
   - 在堆中，插入操作（`insert`）和删除操作（尤其是删除最大/最小元素，即`extract`）都能在对数时间内完成，时间复杂度为 `O(log n)`。
   - 例如，最小堆可以在 `O(log n)` 时间内提取最小元素，并且在插入新元素时也能保证堆的性质（即父节点的值小于或等于子节点的值）。
2. **堆的结构保证了优先级排序**：
   - 堆是一种完全二叉树，满足堆的性质：对于最小堆，每个父节点的值都小于或等于其子节点的值；对于最大堆，每个父节点的值都大于或等于其子节点的值。
   - 这种结构使得优先队列的元素能根据优先级有序排列，且根节点始终是优先队列中最大或最小的元素。
3. **空间效率**：
   - 堆通常通过数组实现，采用数组索引来存储元素的位置。这样能够节省空间，并且避免了需要额外的指针或其他数据结构的开销。
4. **不需要排序整个队列**：
   - 每次只需要对根节点进行插入或删除操作，而不需要每次都排序整个队列，这相比于直接使用排序算法（如快速排序）更为高效。

因此，堆能够在保证高效性和有序性的同时，提供对优先队列常用操作（如插入、删除最大/最小元素等）的高效支持。这就是为什么堆被广泛用于实现优先队列。



优先队列（Priority Queue）是一种数据结构，它与普通队列的不同之处在于，队列中的每个元素都有一个优先级。元素按照优先级顺序出队，而不是按照插入顺序出队。

### 优先队列的特点：

1. **元素有优先级**：
   - 每个元素都有一个与之关联的优先级。优先级较高的元素会先被处理。
   - 优先队列可以用不同方式定义优先级：比如，较大的数代表较高的优先级，或者较小的数代表较高的优先级，这取决于具体实现。
2. **出队顺序依赖于优先级**：
   - 与普通队列（FIFO）不同，优先队列中的元素按照优先级顺序出队，优先级较高的元素会被优先处理。
   - 在最大优先队列中，优先级最高的元素会被最先出队；在最小优先队列中，优先级最低的元素会最先出队。
3. **常见操作**：
   - **插入（Insert）**：将一个元素和其优先级插入队列。
   - **删除（Delete）**：删除队列中的元素，通常是优先级最高或最低的元素。
   - **获取最大/最小优先级元素（Peek）**：返回队列中优先级最高或最低的元素，而不删除它。

### 实现方式：

优先队列可以使用多种数据结构来实现，常见的实现方式包括：

- **堆（Heap）**：如前所述，使用堆来实现优先队列非常高效，因为堆能够提供对最大或最小元素的快速访问（`O(log n)` 时间复杂度）。
- **无序列表**：通过简单的列表结构，插入元素时将其放入队列，但删除时需要扫描整个队列寻找优先级最高的元素，时间复杂度为 `O(n)`。
- **有序列表**：队列始终保持有序状态，每次插入都在正确的位置插入元素，但插入操作的时间复杂度为 `O(n)`，删除操作的时间复杂度为 `O(1)`。

### 应用场景：

- **任务调度**：操作系统的任务调度算法（如优先级调度）常常使用优先队列，任务按照优先级排队。
- **Dijkstra 算法**：在计算最短路径的算法中，优先队列用于选择下一个最短路径的节点。
- **事件模拟**：在离散事件模拟中，事件的执行顺序通常由优先队列决定。

总的来说，优先队列是一种非常有用的数据结构，它允许你根据元素的优先级来控制队列中的处理顺序，而不完全依赖于元素的插入顺序。