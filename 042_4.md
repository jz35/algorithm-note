# **第42课：对数器打表找规律的技巧**

### 1. 算法题

- 给定长度为 `n` 的字符串，字符集为 `r`、`e`、`d`，我们可以通过拼接这三个字符生成字符串。
- 如果生成的字符串中 **有且仅有一个长度 >= 2 的回文子串**，则该字符串称为“好串”。
- 任务是返回长度为 `n` 的所有可能的字符串中，“好串”有多少个。
- 结果对 `1000000007` 取模，1 <= n <= 10^9。

### 2.  C++ 代码

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 检查字符串s从l到r的位置是否为回文
bool isPalindrome(const vector<char>& s, int l, int r) {
    while (l < r) {
        if (s[l] != s[r]) {
            return false;
        }
        l++;
        r--;
    }
    return true;
}

// 方法1：暴力方法，通过生成所有的字符串来检查每一个字符串是否符合条件
int num1(int n) {
    vector<char> path(n);  // 用来存储当前的字符串
    return f(path, 0);  // 从第0个位置开始生成字符串
}

// 递归方法来生成字符串，判断是否为“好串”
int f(vector<char>& path, int i) {
    if (i == path.size()) {  // 到达字符串末尾时检查回文子串
        int cnt = 0;  // 记录回文子串的数量
        for (int l = 0; l < path.size(); l++) {
            for (int r = l + 1; r < path.size(); r++) {
                if (isPalindrome(path, l, r)) {  // 检查当前子串是否为回文
                    cnt++;
                }
                if (cnt > 1) {  // 如果回文子串数量超过1个，则不符合“好串”条件
                    return 0;
                }
            }
        }
        return cnt == 1 ? 1 : 0;  // 仅有一个回文子串时，返回1，否则返回0
    } else {
        int ans = 0;
        // 尝试填充'r', 'e', 'd'三种字符
        path[i] = 'r';
        ans += f(path, i + 1);
        path[i] = 'e';
        ans += f(path, i + 1);
        path[i] = 'd';
        ans += f(path, i + 1);
        return ans;
    }
}

// 方法2：优化方法，通过观察规律简化计算
int num2(int n) {
    if (n == 1) {
        return 0;
    }
    if (n == 2) {
        return 3;  // 长度为2的“好串”有3个
    }
    if (n == 3) {
        return 18;  // 长度为3的“好串”有18个
    }
    // 根据推导出来的规律计算“好串”的数量
    return (int)((long long)6 * (n + 1) % 1000000007);  // 对结果取模1000000007
}

int main() {
    // 测试num1方法对于1到10的长度的输出
    for (int i = 1; i <= 10; i++) {
        cout << "长度为" << i << ", 答案: " << num1(i) << endl;
    }
    return 0;
}
```

### 3. 解释

#### 方法1：暴力方法

- 我们用递归的方法生成所有可能的字符串，通过回溯的方式填充字符 `'r'`, `'e'`, `'d'`。在每次生成一个字符串时，检查它是否为“好串”，即检查它是否包含且仅包含一个长度大于等于2的回文子串。
- `isPalindrome` 函数用来判断一个子串是否是回文。
- 递归到字符串末尾时，统计回文子串的数量，若回文子串的数量大于1，则返回 `0`，否则返回 `1`。

#### 方法2：优化方法

- 通过观察规律，我们发现对于较小的 `n` 值（例如 `n = 1`, `n = 2`, `n = 3`），有明确的答案。
- 对于较大的 `n` 值，利用推导的公式来计算“好串”的数量。通过数学分析，得到了一个简洁的公式：`(6 * (n + 1)) % 1000000007`，这个公式能够快速计算出结果。

#### 复杂度分析：

- **方法1**：时间复杂度是指数级的，因为它生成所有可能的字符串并检查每个字符串的回文子串，因此对于大规模的 `n` 值，性能不可接受。
- **方法2**：时间复杂度是 `O(1)`，因为它直接利用公式计算结果，适用于大规模的 `n` 值。

#### 结果输出：

- 程序输出了从 `n = 1` 到 `n = 10` 的所有“好串”数量。

### 总结

- 方法1是暴力解法，适用于较小的 `n` 值，能够用来验证问题的解决方式。
- 方法2是优化解法，利用了数学规律，在 `n` 较大时能够快速计算出答案，适用于大规模的数据。