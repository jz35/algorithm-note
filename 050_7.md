# 第50课：双指针技巧及相关题目

### 算法笔记：缺失的第一个正数

#### **题目描述**

给定一个未排序的整数数组 `nums`，请找出其中没有出现的最小正整数。要求时间复杂度为 O(n)，并且只使用常数级别额外空间的解决方案。

#### **解题思路**

1. **目标**：将数组中的元素调整到它们应该出现的位置，即元素 `nums[i]` 应该放在 `i + 1` 这个位置上。

2. **方法**：使用原地交换元素，将每个元素放到它应处的位置。如果一个元素在正确的位置上，继续检查下一个元素。如果不在正确的位置，就将它交换到正确位置。

3. 主要步骤

   ：

   - 对于每个元素 `nums[i]`，如果 `nums[i]` 小于等于 `0` 或大于数组长度，或者 `nums[i]` 已经在正确的位置上（即 `nums[i] == i + 1`），跳过。
   - 否则，交换 `nums[i]` 和 `nums[nums[i] - 1]`，直到数组中的元素都在正确的位置上。
   - 最后，第一个未能放到正确位置的索引 `l` 对应的 `l + 1` 就是缺失的最小正整数。

#### **代码实现**

```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    // 时间复杂度 O(n)，空间复杂度 O(1)
    int firstMissingPositive(vector<int>& nums) {
        int l = 0;  // l 是已经正确放置元素的位置指针
        int r = nums.size();  // r 是数组的垃圾区域的起始位置

        // 遍历整个数组
        while (l < r) {
            // 如果当前元素已经放在正确的位置上（即 nums[l] == l + 1）
            if (nums[l] == l + 1) {
                l++;  // 继续检查下一个位置
            }
            // 如果当前元素小于等于 l 或大于 r，或者当前元素已经在正确的位置上（去重）
            else if (nums[l] <= l || nums[l] > r || nums[nums[l] - 1] == nums[l]) {
                swap(nums, l, --r);  // 将该元素移动到垃圾区域
            }
            // 如果当前元素可以交换到正确的位置
            else {
                swap(nums, l, nums[l] - 1);  // 交换到正确的位置
            }
        }
        return l + 1;  // l 就是第一个缺失的正数
    }

private:
    // 辅助函数：交换数组中两个元素的值
    void swap(vector<int>& arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
};
```

#### **复杂度分析**

- **时间复杂度**：O(n)，每个元素最多交换一次，因此时间复杂度为 O(n)。
- **空间复杂度**：O(1)，除了输入数组外，使用了常数级别的额外空间。

#### **算法步骤**

1. 初始化指针 `l = 0` 和 `r = nums.size()`。
2. 使用一个 while 循环遍历数组，检查每个元素是否在正确的位置上：
   - 如果 `nums[l]` 在正确位置上，指针 `l` 自增。
   - 如果 `nums[l]` 小于等于 0 或大于数组长度，或者已经在正确位置，指针 `r` 自减，交换元素。
   - 如果 `nums[l]` 不在正确位置，将其交换到正确位置。
3. 返回 `l + 1`，即为缺失的最小正整数。

#### **示例**

- 输入：

  ```
  [1, 2, 0]
  ```

  - **输出**：`3`
  - **解释**：数组中缺失的最小正整数是 `3`。

- 输入：

  ```
  [3, 4, -1, 1]
  ```

  - **输出**：`2`
  - **解释**：数组中缺失的最小正整数是 `2`。

#### **总结**

- 通过原地交换来调整元素位置，使得每个元素尽量放在它应当出现的位置。
- 通过遍历一遍数组，能够在 O(n) 时间复杂度内找到缺失的第一个正数，并且只使用 O(1) 的额外空间。