# **è®°å¿†åŒ–é€’å½’ï¼ˆMemorized Recursionï¼‰**

**å®šä¹‰**ï¼š
 è®°å¿†åŒ–é€’å½’æ˜¯ä¸€ç§ç»“åˆ **é€’å½’** å’Œ **åŠ¨æ€è§„åˆ’ï¼ˆDPï¼‰** çš„ä¼˜åŒ–æŠ€æœ¯ï¼Œä¸»è¦ç”¨äºé¿å… **é‡å¤è®¡ç®—**ï¼Œæé«˜æ•ˆç‡ã€‚

**æ ¸å¿ƒæ€æƒ³**ï¼š

- åœ¨é€’å½’è¿‡ç¨‹ä¸­ï¼Œ**ç”¨ä¸€ä¸ªæ•°æ®ç»“æ„ï¼ˆå¦‚å“ˆå¸Œè¡¨ã€æ•°ç»„ï¼‰å­˜å‚¨å·²ç»è®¡ç®—è¿‡çš„ç»“æœ**ï¼Œé¿å…é‡å¤è®¡ç®—ç›¸åŒå­é—®é¢˜ã€‚
- å¦‚æœå†æ¬¡é‡åˆ°ç›¸åŒçš„è¾“å…¥ï¼Œå°±ç›´æ¥ä»å­˜å‚¨çš„æ•°æ®ç»“æ„ä¸­å–å‡ºç»“æœï¼Œè€Œä¸é‡æ–°è®¡ç®—ã€‚

------

## **å¯¹æ¯”æ™®é€šé€’å½’ vs è®°å¿†åŒ–é€’å½’**

### **æ™®é€šé€’å½’**

åœ¨æ²¡æœ‰è®°å¿†åŒ–çš„æƒ…å†µä¸‹ï¼Œé€’å½’å¯èƒ½ä¼š **é‡å¤è®¡ç®—ç›¸åŒçš„å­é—®é¢˜**ï¼Œå¯¼è‡´ **æŒ‡æ•°çº§æ—¶é—´å¤æ‚åº¦**ã€‚
 ä¾‹å¦‚ï¼Œåœ¨ **æ–æ³¢é‚£å¥‘æ•°åˆ—** ä¸­ï¼š

```cpp
int fib(int n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}
```

ğŸ”´ **é—®é¢˜**ï¼š

- `fib(n-1)` å’Œ `fib(n-2)` ä¼šé‡å¤è®¡ç®— `fib(n-3)`, `fib(n-4)`...
- å¯¼è‡´ **å¤§é‡é‡å¤è®¡ç®—**ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ **O(2^N)**ï¼Œæ•ˆç‡æä½ã€‚

------

### **è®°å¿†åŒ–é€’å½’**

æˆ‘ä»¬å¯ä»¥ **ç”¨å“ˆå¸Œè¡¨æˆ–æ•°ç»„ç¼“å­˜å·²ç»è®¡ç®—è¿‡çš„ç»“æœ**ï¼Œä¼˜åŒ–æ€§èƒ½ï¼š

```cpp
#include <unordered_map>

class Solution {
public:
    std::unordered_map<int, int> memo; // å“ˆå¸Œè¡¨ç¼“å­˜è®¡ç®—ç»“æœ
    
    int fib(int n) {
        if (n <= 1) return n;
        if (memo.count(n)) return memo[n]; // å¦‚æœå·²ç»è®¡ç®—è¿‡ï¼Œç›´æ¥è¿”å›
        return memo[n] = fib(n - 1) + fib(n - 2); // è®¡ç®—å¹¶å­˜å‚¨ç»“æœ
    }
};
```

âœ… **ä¼˜åŒ–ç‚¹**ï¼š

- **å‡å°‘é‡å¤è®¡ç®—**ï¼šæ¯ä¸ª `fib(n)` åªè®¡ç®— **ä¸€æ¬¡**ï¼Œä»¥åç›´æ¥è¿”å›å­˜å‚¨çš„å€¼ã€‚
- **æ—¶é—´å¤æ‚åº¦é™ä¸º O(N)**ï¼Œæ¯”æ™®é€šé€’å½’ **O(2^N)** å¿«å¾—å¤šã€‚

------

## **åœ¨ã€Œæ‰“å®¶åŠ«èˆ IIIã€ä¸­çš„åº”ç”¨**

**æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è®°å¿†åŒ–é€’å½’æ¥ä¼˜åŒ– `rob(TreeNode\* root)`ï¼Œé¿å…é‡å¤è®¡ç®—ç›¸åŒå­æ ‘çš„æœ€å¤§æ”¶ç›Šã€‚**

### **æ™®é€šé€’å½’ï¼ˆæœªä¼˜åŒ–ï¼‰**

```cpp
pair<int, int> dfs(TreeNode* root) {
    if (!root) return {0, 0};

    pair<int, int> left = dfs(root->left);
    pair<int, int> right = dfs(root->right);

    int robThis = root->val + left.second + right.second;
    int notRobThis = max(left.first, left.second) + max(right.first, right.second);

    return {robThis, notRobThis};
}
```

ğŸ”´ **é—®é¢˜**ï¼š

- `dfs(root->left)` å’Œ `dfs(root->right)` å¯èƒ½ä¼šé‡å¤è®¡ç®—æŸä¸ªå­æ ‘çš„ `rob` å€¼ã€‚

------

### **è®°å¿†åŒ–é€’å½’ä¼˜åŒ–**

æˆ‘ä»¬å¯ä»¥ç”¨ **`unordered_map<TreeNode\*, pair<int, int>> memo`** è®°å¿†åŒ– `dfs(root)` è®¡ç®—çš„ç»“æœï¼š

```cpp
#include <unordered_map>

class Solution {
public:
    std::unordered_map<TreeNode*, pair<int, int>> memo; // è®°å¿†åŒ–å­˜å‚¨è®¡ç®—ç»“æœ
    
    pair<int, int> dfs(TreeNode* root) {
        if (!root) return {0, 0};
        
        // å¦‚æœå·²ç»è®¡ç®—è¿‡å½“å‰èŠ‚ç‚¹ï¼Œç›´æ¥è¿”å›ç¼“å­˜å€¼
        if (memo.count(root)) return memo[root];

        // é€’å½’è®¡ç®—å·¦å­æ ‘å’Œå³å­æ ‘
        pair<int, int> left = dfs(root->left);
        pair<int, int> right = dfs(root->right);

        // è®¡ç®—å· / ä¸å·å½“å‰èŠ‚ç‚¹çš„æœ€å¤§æ”¶ç›Š
        int robThis = root->val + left.second + right.second;
        int notRobThis = max(left.first, left.second) + max(right.first, right.second);

        // å­˜å‚¨ç»“æœåˆ°å“ˆå¸Œè¡¨ï¼Œå¹¶è¿”å›
        return memo[root] = {robThis, notRobThis};
    }

    int rob(TreeNode* root) {
        pair<int, int> result = dfs(root);
        return max(result.first, result.second);
    }
};
```

âœ… **ä¼˜åŒ–ç‚¹**ï¼š

- **é¿å…é‡å¤è®¡ç®—**ï¼Œå­˜å‚¨æ¯ä¸ªå­æ ‘çš„ `rob` ç»“æœã€‚
- **æ—¶é—´å¤æ‚åº¦ O(N)**ï¼Œæ¯”æ™®é€šé€’å½’æ›´å¿«ã€‚

------

## **æ€»ç»“**

ğŸ”¹ **æ™®é€šé€’å½’çš„é—®é¢˜**ï¼šé‡å¤è®¡ç®—ç›¸åŒå­é—®é¢˜ï¼Œå¯¼è‡´æŒ‡æ•°çº§å¤æ‚åº¦ã€‚
 ğŸ”¹ **è®°å¿†åŒ–é€’å½’çš„ä¼˜åŒ–**ï¼š

- **ç”¨å“ˆå¸Œè¡¨æˆ–æ•°ç»„å­˜å‚¨å·²ç»è®¡ç®—çš„ç»“æœ**ã€‚
- **å¦‚æœé‡åˆ°ç›¸åŒè¾“å…¥ï¼Œç›´æ¥è¿”å›å­˜å‚¨çš„ç»“æœ**ï¼Œé¿å…é‡å¤è®¡ç®—ã€‚
- **å¤§å¹…é™ä½æ—¶é—´å¤æ‚åº¦ï¼Œä» O(2^N) é™åˆ° O(N)**ã€‚

ğŸ”¹ **è®°å¿†åŒ–é€’å½’é€‚ç”¨äº**ï¼š

- æ–æ³¢é‚£å¥‘æ•°åˆ—
- æ ‘å½¢ DPï¼ˆå¦‚æ‰“å®¶åŠ«èˆ IIIï¼‰
- èƒŒåŒ…é—®é¢˜
- å…¶ä»– **æœ‰é‡å¤å­é—®é¢˜** çš„é€’å½’é—®é¢˜



# unordered_map

`std::unordered_map` æ˜¯ C++ æ ‡å‡†åº“æä¾›çš„ä¸€ç§å“ˆå¸Œè¡¨å®ç°ï¼Œå®ƒé€šè¿‡å“ˆå¸Œå‡½æ•°æ¥å®ç°å¿«é€Ÿçš„é”®å€¼å¯¹æŸ¥æ‰¾ã€‚ä¸ `std::map` ä¸åŒï¼Œ`std::unordered_map` ä¸ä¼šæŒ‰ç…§é”®çš„é¡ºåºæ’åºï¼Œè€Œæ˜¯æ ¹æ®å“ˆå¸Œå€¼è¿›è¡Œå­˜å‚¨å’ŒæŸ¥æ‰¾ã€‚å› æ­¤ï¼ŒæŸ¥æ‰¾æ“ä½œçš„æ—¶é—´å¤æ‚åº¦é€šå¸¸æ˜¯ **O(1)**ï¼Œä½†åœ¨æœ€åæƒ…å†µä¸‹ä¼šé€€åŒ–ä¸º **O(N)**ï¼Œè¿™å–å†³äºå“ˆå¸Œå‡½æ•°çš„è´¨é‡å’Œå†²çªè§£å†³ç­–ç•¥ã€‚

ä»¥ä¸‹æ˜¯ `std::unordered_map` ä¸­å¸¸è§çš„å‡½æ•°å’Œç”¨æ³•ï¼š

### **1. æ’å…¥å…ƒç´ **

#### `insert`

- å‘ `unordered_map` ä¸­æ’å…¥ä¸€ä¸ªå…ƒç´ ã€‚å¦‚æœé”®å·²å­˜åœ¨ï¼Œæ’å…¥å¤±è´¥ï¼Œä¸”ä¸ä¼šè¦†ç›–ç°æœ‰å€¼ã€‚

```cpp
std::unordered_map<int, std::string> umap;
umap.insert({1, "one"});  // æ’å…¥é”®å€¼å¯¹ {1, "one"}
umap.insert({2, "two"});  // æ’å…¥é”®å€¼å¯¹ {2, "two"}
```

#### `emplace`

- ä¸ `insert` ç±»ä¼¼ï¼Œä½† `emplace` åœ¨æ’å…¥å…ƒç´ æ—¶ï¼Œèƒ½å¤Ÿç›´æ¥æ„é€ å…ƒç´ ï¼Œé¿å…é¢å¤–çš„æ‹·è´æˆ–ç§»åŠ¨æ“ä½œã€‚

```cpp
umap.emplace(3, "three");  // ä½¿ç”¨æ„é€ å‡½æ•°ç›´æ¥æ’å…¥å…ƒç´ 
```

### **2. æŸ¥æ‰¾å…ƒç´ **

#### `find`

- æŸ¥æ‰¾ç‰¹å®šçš„é”®ã€‚å¦‚æœæ‰¾åˆ°ï¼Œè¿”å›æŒ‡å‘è¯¥å…ƒç´ çš„è¿­ä»£å™¨ï¼›å¦‚æœæ‰¾ä¸åˆ°ï¼Œè¿”å› `end()` è¿­ä»£å™¨ã€‚

```cpp
auto it = umap.find(2);
if (it != umap.end()) {
    std::cout << "Found: " << it->second << std::endl;  // è¾“å‡º "Found: two"
} else {
    std::cout << "Not Found" << std::endl;
}
```

#### `count`

- è¿”å›ç‰¹å®šé”®çš„å‡ºç°æ¬¡æ•°ï¼Œ`unordered_map` ä¸­é”®æ˜¯å”¯ä¸€çš„ï¼Œå› æ­¤è¦ä¹ˆæ˜¯ 0ï¼Œè¦ä¹ˆæ˜¯ 1ã€‚

```cpp
if (umap.count(3)) {
    std::cout << "Key 3 exists" << std::endl;
} else {
    std::cout << "Key 3 does not exist" << std::endl;
}
```

### **3. è®¿é—®å…ƒç´ **

#### `operator[]`

- é€šè¿‡é”®è®¿é—®å…ƒç´ ã€‚å¦‚æœé”®ä¸å­˜åœ¨ï¼Œä¼šæ’å…¥ä¸€ä¸ªé»˜è®¤å€¼ã€‚

```cpp
std::cout << umap[1] << std::endl;  // è¾“å‡º "one"
umap[4] = "four";  // å¦‚æœé”® 4 ä¸å­˜åœ¨ï¼Œå°†å…¶æ’å…¥å¹¶èµ‹å€¼ä¸º "four"
```

#### `at`

- è®¿é—®å…ƒç´ ï¼Œå¦‚æœé”®ä¸å­˜åœ¨ï¼ŒæŠ›å‡º `std::out_of_range` å¼‚å¸¸ã€‚

```cpp
try {
    std::cout << umap.at(2) << std::endl;  // è¾“å‡º "two"
    std::cout << umap.at(5) << std::endl;  // æŠ›å‡ºå¼‚å¸¸
} catch (const std::out_of_range& e) {
    std::cout << e.what() << std::endl;  // è¾“å‡º "map::at: key not found"
}
```

### **4. åˆ é™¤å…ƒç´ **

#### `erase`

- åˆ é™¤æŒ‡å®šé”®çš„å…ƒç´ ï¼Œå¯ä»¥æ ¹æ®é”®æˆ–è€…è¿­ä»£å™¨åˆ é™¤ã€‚

```cpp
umap.erase(2);  // åˆ é™¤é”® 2 å¯¹åº”çš„å…ƒç´ 
auto it = umap.find(3);
umap.erase(it);  // ä½¿ç”¨è¿­ä»£å™¨åˆ é™¤é”® 3 å¯¹åº”çš„å…ƒç´ 
```

#### `clear`

- åˆ é™¤æ‰€æœ‰å…ƒç´ ï¼Œæ¸…ç©º `unordered_map`ã€‚

```cpp
umap.clear();  // æ¸…ç©º unordered_map ä¸­çš„æ‰€æœ‰å…ƒç´ 
```

### **5. å®¹å™¨ä¿¡æ¯**

#### `size`

- è¿”å› `unordered_map` ä¸­å…ƒç´ çš„æ•°é‡ã€‚

```cpp
std::cout << umap.size() << std::endl;  // è¾“å‡ºå½“å‰å…ƒç´ çš„ä¸ªæ•°
```

#### `empty`

- æ£€æŸ¥ `unordered_map` æ˜¯å¦ä¸ºç©ºã€‚

```cpp
if (umap.empty()) {
    std::cout << "The map is empty." << std::endl;
} else {
    std::cout << "The map is not empty." << std::endl;
}
```

### **6. æ¡¶ä¿¡æ¯**

#### `bucket_count`

- è¿”å›å“ˆå¸Œè¡¨ä¸­æ¡¶çš„æ•°é‡ã€‚`unordered_map` åº•å±‚ä½¿ç”¨æ¡¶ï¼ˆbucketï¼‰æ¥å­˜å‚¨å…ƒç´ ï¼Œé€šè¿‡å“ˆå¸Œå‡½æ•°å°†å…ƒç´ æ˜ å°„åˆ°ä¸åŒçš„æ¡¶ä¸­ã€‚

```cpp
std::cout << "Number of buckets: " << umap.bucket_count() << std::endl;
```

#### `bucket_size`

- è¿”å›ç‰¹å®šæ¡¶ä¸­å…ƒç´ çš„æ•°é‡ã€‚

```cpp
std::cout << "Bucket 0 has " << umap.bucket_size(0) << " elements." << std::endl;
```

#### `load_factor`

- è¿”å›è´Ÿè½½å› å­ï¼Œè¡¨ç¤ºå½“å‰æ¡¶ä¸­å…ƒç´ çš„å¹³å‡æ•°é‡ã€‚

```cpp
std::cout << "Load factor: " << umap.load_factor() << std::endl;
```

------

### **ç¤ºä¾‹ä»£ç **

```cpp
#include <iostream>
#include <unordered_map>

int main() {
    std::unordered_map<int, std::string> umap;

    // æ’å…¥å…ƒç´ 
    umap.insert({1, "one"});
    umap[2] = "two";
    umap.emplace(3, "three");

    // æŸ¥æ‰¾å…ƒç´ 
    auto it = umap.find(2);
    if (it != umap.end()) {
        std::cout << "Found: " << it->second << std::endl;  // è¾“å‡º "Found: two"
    }

    // è®¿é—®å…ƒç´ 
    std::cout << umap[1] << std::endl;  // è¾“å‡º "one"
    umap[4] = "four";  // æ–°æ’å…¥å…ƒç´ 
    std::cout << umap.at(4) << std::endl;  // è¾“å‡º "four"

    // åˆ é™¤å…ƒç´ 
    umap.erase(2);  // åˆ é™¤é”® 2 çš„å…ƒç´ 
    umap.clear();  // æ¸…ç©º unordered_map

    std::cout << "Size after clear: " << umap.size() << std::endl;  // è¾“å‡º 0
}
```

### **æ€»ç»“**

- `std::unordered_map` æä¾›äº†ä¸€äº›å¸¸ç”¨çš„å‡½æ•°æ¥æ’å…¥ã€æŸ¥æ‰¾ã€åˆ é™¤å…ƒç´ ï¼Œä»¥åŠè·å–å®¹å™¨çš„å¤§å°ã€æ¡¶ä¿¡æ¯ç­‰ã€‚
- å¸¸ç”¨çš„å‡½æ•°åŒ…æ‹¬ `insert()`, `emplace()`, `find()`, `operator[]`, `erase()`, `size()`, `clear()` ç­‰ã€‚
- ä½¿ç”¨å“ˆå¸Œè¡¨ï¼Œ`unordered_map` æä¾›å¹³å‡å¸¸æ•°æ—¶é—´å¤æ‚åº¦ï¼ˆO(1)ï¼‰çš„æŸ¥æ‰¾ã€æ’å…¥å’Œåˆ é™¤æ“ä½œã€‚



# priority_queue

`priority_queue` æ˜¯ C++ STL ä¸­çš„ä¸€ä¸ªå®¹å™¨é€‚é…å™¨ï¼Œç”¨äºå®ç°ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆpriority queueï¼‰ã€‚ä¼˜å…ˆé˜Ÿåˆ—æ˜¯ä¸€ç§åŸºäºå †ï¼ˆheapï¼‰å®ç°çš„æ•°æ®ç»“æ„ï¼Œå®ƒèƒ½å¤Ÿç¡®ä¿æ¯æ¬¡æå–å…ƒç´ æ—¶éƒ½èƒ½å¾—åˆ°é˜Ÿåˆ—ä¸­ä¼˜å…ˆçº§æœ€é«˜çš„å…ƒç´ ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œ`priority_queue` æ˜¯ä¸€ä¸ªæœ€å¤§å †ï¼ˆæœ€å¤§ä¼˜å…ˆé˜Ÿåˆ—ï¼‰ï¼Œå³é˜Ÿåˆ—å¤´éƒ¨æ€»æ˜¯ä¼˜å…ˆçº§æœ€é«˜çš„å…ƒç´ ã€‚å¦‚æœæƒ³è¦å®ç°æœ€å°ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå¯ä»¥é€šè¿‡æŒ‡å®šæ¯”è¾ƒå‡½æ•°æ¥å®ç°ã€‚

### `priority_queue` å¸¸è§å‡½æ•°

1. **æ„é€ å‡½æ•°**

   - `priority_queue()`: é»˜è®¤æ„é€ å‡½æ•°ï¼Œåˆ›å»ºä¸€ä¸ªç©ºçš„ä¼˜å…ˆé˜Ÿåˆ—ï¼Œé»˜è®¤é‡‡ç”¨æœ€å¤§å †ã€‚
   - `priority_queue(const Compare& comp)`: ä½¿ç”¨è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°æˆ–è°“è¯åˆ›å»ºä¼˜å…ˆé˜Ÿåˆ—ã€‚
   - `priority_queue(container_type&& c, const Compare& comp = Compare())`: ç”¨ç»™å®šå®¹å™¨å’Œæ¯”è¾ƒå‡½æ•°æ„é€ ä¼˜å…ˆé˜Ÿåˆ—ã€‚

2. **æˆå‘˜å‡½æ•°**

   - **`empty()`**

     - **åŠŸèƒ½**: æ£€æŸ¥ä¼˜å…ˆé˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºã€‚

     - **è¿”å›å€¼**: å¦‚æœé˜Ÿåˆ—ä¸ºç©ºï¼Œè¿”å› `true`ï¼Œå¦åˆ™è¿”å› `false`ã€‚

     - ç¤ºä¾‹:

       ```cpp
        std::priority_queue<int> pq;
       if (pq.empty()) {
           std::cout << "Priority queue is empty!" << std::endl;
       }
       ```
     
   - **`size()`**

     - **åŠŸèƒ½**: è¿”å›ä¼˜å…ˆé˜Ÿåˆ—ä¸­å…ƒç´ çš„ä¸ªæ•°ã€‚

     - **è¿”å›å€¼**: å½“å‰é˜Ÿåˆ—ä¸­å…ƒç´ çš„æ•°é‡ã€‚

     - ç¤ºä¾‹:

       ```cpp
        std::cout << "Size of priority queue: " << pq.size() << std::endl;
       ```
    
   - **`top()`**
   
     - **åŠŸèƒ½**: è¿”å›ä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„æœ€å¤§å…ƒç´ ï¼ˆæ ¹æ®ä¼˜å…ˆçº§ï¼‰ï¼Œä½†ä¸åˆ é™¤å®ƒã€‚

     - **è¿”å›å€¼**: è¿”å›é˜Ÿåˆ—é¡¶éƒ¨çš„å…ƒç´ ï¼ˆä¼˜å…ˆçº§æœ€é«˜çš„å…ƒç´ ï¼‰ã€‚

     - ç¤ºä¾‹:

       ```cpp
        std::priority_queue<int> pq;
       pq.push(10);
        pq.push(20);
       std::cout << "Top element: " << pq.top() << std::endl;  // è¾“å‡º 20
    ```
     
   - **`push(const T& value)`**
   
     - **åŠŸèƒ½**: å‘ä¼˜å…ˆé˜Ÿåˆ—ä¸­æ’å…¥ä¸€ä¸ªå…ƒç´ ã€‚
   
     - **è¿”å›å€¼**: æ— è¿”å›å€¼ã€‚
   
     - ç¤ºä¾‹:
   
       ```cpp
    std::priority_queue<int> pq;
       pq.push(10);
    pq.push(20);
       pq.push(5);
    ```
   
- **`pop()`**
  
     - **åŠŸèƒ½**: ç§»é™¤ä¼˜å…ˆé˜Ÿåˆ—ä¸­çš„æœ€å¤§å…ƒç´ ï¼ˆä¼˜å…ˆçº§æœ€é«˜çš„å…ƒç´ ï¼‰ã€‚
     
     - **è¿”å›å€¼**: æ— è¿”å›å€¼ã€‚
     
     - ç¤ºä¾‹:

       ```cpp
      std::priority_queue<int> pq;
       pq.push(10);
      pq.push(20);
       pq.push(5);
      pq.pop();  // ç§»é™¤ 20
       std::cout << "Top element after pop: " << pq.top() << std::endl;  // è¾“å‡º 10
    ```
    
- **`swap(priority_queue& other)`**
  
     - **åŠŸèƒ½**: äº¤æ¢ä¸¤ä¸ªä¼˜å…ˆé˜Ÿåˆ—çš„å†…å®¹ã€‚
     
     - **è¿”å›å€¼**: æ— è¿”å›å€¼ã€‚
     
     - ç¤ºä¾‹:
     
       ```cpp
      std::priority_queue<int> pq1;
       std::priority_queue<int> pq2;
      pq1.push(10);
       pq2.push(20);
      pq1.swap(pq2);  // äº¤æ¢ pq1 å’Œ pq2 çš„å†…å®¹
      ```

3. **è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°** `priority_queue` é»˜è®¤ä½¿ç”¨æœ€å¤§å †ï¼Œå¦‚æœè¦ä½¿ç”¨æœ€å°å †ï¼Œå¯ä»¥é€šè¿‡è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°æ¥å®ç°ã€‚ä»¥ä¸‹æ˜¯å¦‚ä½•è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°çš„ç¤ºä¾‹ï¼š

   - **æœ€å°å †çš„ç¤ºä¾‹**:

     ```cpp
     #include <iostream>
     #include <queue>
     #include <vector>
     
     struct Compare {
         bool operator()(int a, int b) {
             return a > b;  // å°çš„ä¼˜å…ˆ
         }
     };
     
     int main() {
         std::priority_queue<int, std::vector<int>, Compare> minHeap;
         minHeap.push(10);
         minHeap.push(20);
         minHeap.push(5);
         std::cout << "Top element (min-heap): " << minHeap.top() << std::endl;  // è¾“å‡º 5
         return 0;
     }
     ```

   - **è‡ªå®šä¹‰å¯¹è±¡çš„ç¤ºä¾‹**: å¦‚æœéœ€è¦å¯¹è‡ªå®šä¹‰å¯¹è±¡è¿›è¡Œæ’åºï¼Œå¯ä»¥ä¼ å…¥ä¸€ä¸ªè‡ªå®šä¹‰çš„æ¯”è¾ƒå‡½æ•°æˆ–è°“è¯ï¼š

     ```cpp
     #include <iostream>
     #include <queue>
     #include <vector>
     
     struct Person {
         std::string name;
         int age;
     };
     
     struct ComparePerson {
         bool operator()(const Person& p1, const Person& p2) {
             return p1.age > p2.age;  // å¹´é¾„å°çš„ä¼˜å…ˆ
         }
     };
     
     int main() {
         std::priority_queue<Person, std::vector<Person>, ComparePerson> pq;
         pq.push({"Alice", 30});
         pq.push({"Bob", 25});
         pq.push({"Charlie", 35});
         
         std::cout << "Top element (youngest person): " << pq.top().name << std::endl;  // è¾“å‡º Bob
         return 0;
     }
     ```

### æ€»ç»“

`priority_queue` æ˜¯ C++ STL ä¸­éå¸¸å¼ºå¤§çš„å®¹å™¨ï¼Œå®ƒåŸºäºå †å®ç°ï¼Œé»˜è®¤å®ç°æœ€å¤§å †ã€‚å¸¸è§æ“ä½œå¦‚æ’å…¥ï¼ˆ`push`ï¼‰ã€åˆ é™¤é¡¶éƒ¨å…ƒç´ ï¼ˆ`pop`ï¼‰ã€è·å–é¡¶éƒ¨å…ƒç´ ï¼ˆ`top`ï¼‰ã€æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼ˆ`empty`ï¼‰å’Œè·å–é˜Ÿåˆ—å¤§å°ï¼ˆ`size`ï¼‰ç­‰ã€‚é€šè¿‡è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°ï¼Œå¯ä»¥è½»æ¾åœ°ä¿®æ”¹ä¼˜å…ˆé˜Ÿåˆ—çš„æ’åºæ–¹å¼ï¼ˆå¦‚å®ç°æœ€å°å †ï¼‰ã€‚