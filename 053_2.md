# 第53课：单调栈（下）

### **题目 1：去除重复字母，保证字典序最小**

#### **题目描述：**

给定一个字符串 `s`，请你去除字符串中重复的字母，使得每个字母只出现一次，并且**保证返回结果的字典序最小**。

#### **输入描述：**

- 一个仅包含小写英文字母的字符串 `s`，长度范围：`1 <= s.length <= 10^4`。

#### **输出描述：**

- 返回经过处理后，**字典序最小**的字符串。

#### **算法知识：**

- **单调栈**
- **贪心策略**
- **字符频次统计**

##### [题目链接](https://leetcode.cn/problems/remove-duplicate-letters/)

------

### **代码实现：**

```cpp
class Solution {
public:
    string removeDuplicateLetters(string s) {
        const int MAXN = 26;
        int cnts[MAXN] = {0}; // 统计字符频率
        bool enter[MAXN] = {false}; // 记录字符是否入栈
        char stack[MAXN]; // 固定大小的数组模拟栈
        int r = 0; // 栈顶指针

        // 统计字符出现次数
        for (char ch : s) {
            cnts[ch - 'a']++;
        }

        // 遍历字符串
        for (char cur : s) {
            int index = cur - 'a';
            cnts[index]--; // 当前字符剩余次数减少
            
            if (enter[index]) continue; // 如果字符已入栈，跳过
            
            // 维护单调栈，确保字典序最小
            while (r > 0 && stack[r - 1] > cur && cnts[stack[r - 1] - 'a'] > 0) {
                enter[stack[r - 1] - 'a'] = false;
                r--; // 弹出栈顶元素
            }

            // 当前字符入栈
            stack[r++] = cur;
            enter[index] = true;
        }

        return string(stack, r);
    }
};
```

------

### **过程分析：**

1. **统计字符频率**：计算每个字符出现的次数。
2. 遍历字符串：
   - 若字符已在栈中，跳过。
   - 若栈顶元素比当前字符大，并且后续还会出现，则弹出栈顶元素，以保证字典序最小。
   - 将当前字符入栈，并标记为已使用。
3. **最终返回栈中的字符组成的字符串**。

------

### **题目 2：字典序最小的子序列**

#### **题目描述：**

给定一个字符串 `s`，请你返回**字典序最小的子序列**，该子序列包含 `s` 的所有不同字符，并且只包含一次。

#### **输入描述：**

- 一个仅包含小写英文字母的字符串 `s`，长度范围：`1 <= s.length <= 10^4`。

#### **输出描述：**

- 返回满足条件的字典序最小的字符串。

#### **算法知识：**

- **单调栈**
- **贪心策略**
- **字符频次统计**

##### [题目链接](https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters/)

------

### **代码实现：**

```cpp
class Solution {
public:
    string smallestSubsequence(string s) {
        const int MAXN = 26;
        int cnts[MAXN] = {0}; // 统计字符频率
        bool enter[MAXN] = {false}; // 记录字符是否入栈
        char stack[MAXN]; // 固定大小的数组模拟栈
        int r = 0; // 栈顶指针

        // 统计字符出现次数
        for (char ch : s) {
            cnts[ch - 'a']++;
        }

        // 遍历字符串
        for (char cur : s) {
            int index = cur - 'a';
            cnts[index]--; // 当前字符剩余次数减少
            
            if (enter[index]) continue; // 如果字符已入栈，跳过
            
            // 维护单调栈，确保字典序最小
            while (r > 0 && stack[r - 1] > cur && cnts[stack[r - 1] - 'a'] > 0) {
                enter[stack[r - 1] - 'a'] = false;
                r--; // 弹出栈顶元素
            }

            // 当前字符入栈
            stack[r++] = cur;
            enter[index] = true;
        }

        return string(stack, r);
    }
};
```

------

### **过程分析：**

1. **统计字符频率**：计算每个字符出现的次数。
2. 遍历字符串：
   - 若字符已在栈中，跳过。
   - 若栈顶元素比当前字符大，并且后续还会出现，则弹出栈顶元素，以保证字典序最小。
   - 将当前字符入栈，并标记为已使用。
3. **最终返回栈中的字符组成的字符串**。

------

### **两道题的区别**

| 题目                   | 目标                         | 是否连续                     | 处理方式          |
| ---------------------- | ---------------------------- | ---------------------------- | ----------------- |
| **去重保证字典序最小** | **去掉重复字符**，字典序最小 | 必须是原字符串的子串（连续） | **单调栈 + 贪心** |
| **字典序最小子序列**   | **去掉重复字符**，字典序最小 | 只要是子序列（不要求连续）   | **单调栈 + 贪心** |

这两道题的思路基本一致，核心是 **单调栈 + 贪心策略**，需要重点理解 **"删除字符的条件"** 来维持字典序最小。 🚀