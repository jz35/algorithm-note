# 第52课：单调栈（上）

### 题目：子数组的最小值之和

#### 题目描述：

给定一个整数数组 `arr`，找到 `min(b)` 的总和，其中 `b` 是 `arr` 的每个（连续）子数组。返回所有子数组的最小值之和，答案对 `1000000007` 取模。

#### 输入描述：

- 一个整数数组 `arr`，其中 `1 <= arr.length <= 30000`，`0 <= arr[i] <= 100000`。

#### 输出描述：

- 返回所有子数组最小值之和，对 `1000000007` 取模。

#### 示例：

输入：

```
arr = [3, 1, 2, 4]
```

输出：

```
17
```

#### 说明：

- 对于子数组 `[3]`、`[1]`、`[2]`、`[4]`，它们的最小值分别为 3、1、2、4。
- 对于子数组 `[3, 1]`，最小值为 1。
- 对于子数组 `[1, 2]`，最小值为 1。
- 对于子数组 `[2, 4]`，最小值为 2。
- 对于子数组 `[3, 1, 2]`，最小值为 1。
- 对于子数组 `[1, 2, 4]`，最小值为 1。
- 对于子数组 `[3, 1, 2, 4]`，最小值为 1。
- 所以最小值之和为 `3 + 1 + 2 + 4 + 1 + 1 + 1 + 2 + 1 + 1 + 1 = 17`。

------

### 算法知识

#### 1. **栈的应用**：

- 使用栈来保存元素的下标，通过单调栈来求解每个子数组的最小值。
- 在遍历数组时，如果当前元素小于栈顶元素，则弹出栈顶元素，并计算该栈顶元素作为子数组最小值的贡献。

#### 2. **贡献计算**：

- 每次弹出栈顶元素时，计算它作为子数组最小值的贡献，贡献值是由当前栈顶元素的左边界、右边界以及该元素的值共同决定的。
- 具体公式：`(cur - left) * (right - cur) * arr[cur]`，其中 `cur` 是当前栈顶元素的下标，`left` 是该元素的左边界，`right` 是右边界。

#### 3. **对结果取模**：

- 最终的答案可能非常大，因此每次更新答案时都要对 `1000000007` 取模，防止溢出。

------

### 代码实现

```cpp
#include <vector>
#include <stack>
using namespace std;

class Solution {
public:
    static const int MOD = 1000000007;  // 取模常量
    static const int MAXN = 30001;  // 栈的最大容量
    int sumSubarrayMins(vector<int>& arr) {
        long long ans = 0;  // 存储结果，使用 long long 防止溢出
        int stack[MAXN];  // 栈数组
        int top = 0;  // 栈顶指针，初始为空栈
        
        // 遍历数组
        for (int i = 0; i < arr.size(); i++) {
            // 弹出栈顶元素，直到栈顶元素小于当前元素
            while (top > 0 && arr[stack[top - 1]] >= arr[i]) {
                int cur = stack[--top];  // 获取栈顶元素，并弹出
                int left = top == 0 ? -1 : stack[top - 1];  // 左边界
                // 计算当前最小值对结果的贡献，并加到答案中
                ans = (ans + (long long)(cur - left) * (i - cur) * arr[cur]) % MOD;
            }
            // 将当前下标压入栈
            stack[top++] = i;
        }
        
        // 清算阶段：处理剩余栈内元素
        while (top > 0) {
            int cur = stack[--top];  // 获取栈顶元素，并弹出
            int left = top == 0 ? -1 : stack[top - 1];  // 左边界
            // 计算当前最小值对结果的贡献，并加到答案中
            ans = (ans + (long long)(cur - left) * (arr.size() - cur) * arr[cur]) % MOD;
        }
        
        return (int) ans;  // 返回答案，转为 int 类型
    }
};
```

------

### 代码解释

1. **栈操作**：
   - 我们用一个栈 `stack` 来存储数组的下标。在遍历过程中，当遇到当前元素比栈顶元素小的情况时，我们弹出栈顶元素，计算该元素作为子数组最小值的贡献。
2. **左边界与右边界的计算**：
   - 左边界：每个元素的左边界是指在栈中，当前元素之前的第一个比它小的元素的下标。如果栈为空，说明没有比它小的元素，左边界为 `-1`。
   - 右边界：右边界是当前元素右侧第一个比它小的元素的下标，遍历完数组后右边界会是数组的长度。
3. **最终答案**：
   - 所有的最小值贡献累加起来，最终对 `1000000007` 取模，得到最终答案。

------

### 复杂度分析

- **时间复杂度**：`O(n)`，每个元素最多入栈一次，出栈一次，因此时间复杂度为线性时间。
- **空间复杂度**：`O(n)`，栈最多存储 `n` 个元素，空间复杂度为线性空间。

------

