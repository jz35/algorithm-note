# 第56课：并查集（上）

### 题目描述

给定一个字符串数组 `strs`，其中每个字符串都具有相同的长度。我们称两个字符串相似，当且仅当它们可以通过交换至多两个字符的位置得到对方。返回 `strs` 中相似字符串的组数。

### 输入输出描述

**输入:**

- 一个字符串数组 `strs`，其中每个字符串的长度相同，且 `strs.length` 在 [1, 100] 之间，`strs[i].length` 在 [1, 100] 之间。

**输出:**

- 返回相似字符串的组数。

### 算法知识

1. **并查集（Union-Find）**: 用于处理集合的合并与查询操作，常用于处理连通性问题。此题可以看做是一个图问题，字符串之间的相似性可以表示为图中的边，通过并查集来跟踪连接的组件。
2. **路径压缩**: 在并查集中的查找操作时，通过递归的方式直接将节点的父节点设置为根节点，优化查找效率。
3. **按需合并**: 每当检测到两个字符串相似时，合并它们所属的集合。

### 代码实现

```cpp
class Solution {
public:
    int numSimilarGroups(vector<string>& strs) {
        int n = strs.size();
        int m = strs[0].size();
        vector<int> parent(n); // 并查集数组
        int sets = n; // 初始每个字符串都是独立的集合

        // 并查集初始化
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }

        // 查找根节点（路径压缩）
        function<int(int)> find = [&](int x) {
            return parent[x] == x ? x : (parent[x] = find(parent[x]));
        };

        // 合并集合
        auto unionSet = [&](int x, int y) {
            int fx = find(x), fy = find(y);
            if (fx != fy) {
                parent[fx] = fy;
                sets--;
            }
        };

        // 遍历所有字符串对，检查是否相似
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (find(i) != find(j)) { // 只有不同集合的才去检查是否相似
                    int diff = 0;
                    for (int k = 0; k < m && diff < 3; k++) { 
                        if (strs[i][k] != strs[j][k]) {
                            diff++;
                        }
                    }
                    if (diff == 0 || diff == 2) { // 相似则合并
                        unionSet(i, j);
                    }
                }
            }
        }
        return sets; // 返回最终的独立集合数量
    }
};
```

### 代码解释

1. **并查集初始化**:
   - 初始化并查集数组 `parent`，其中每个字符串最开始都属于不同的集合。
2. **查找根节点函数**:
   - 使用路径压缩技术，通过递归的方式快速查找并更新父节点。
3. **合并集合函数**:
   - 如果两个字符串属于不同的集合，且它们相似（通过比较字符差异），则合并这两个集合，并减少独立集合的数量。
4. **遍历字符串对**:
   - 对每一对不同的字符串进行相似性检查。如果它们的字符差异为0或2，表示它们是相似的，可以合并为一个集合。
5. **返回结果**:
   - 最后，返回所有相似字符串组的数量。

### 复杂度分析

- **时间复杂度**:
  - 查找和合并操作的时间复杂度是近似常数 `O(α(n))`，其中 `α` 是反向阿克曼函数。
  - 外层循环遍历每一对字符串，内层循环比较每对字符串的字符，时间复杂度为 `O(n^2 * m)`，其中 `n` 是字符串数量，`m` 是字符串的长度。
  - 因此，时间复杂度为 `O(n^2 * m)`。
- **空间复杂度**:
  - 使用了一个大小为 `n` 的并查集数组 `parent`，因此空间复杂度为 `O(n)`。

### 过程分析

1. **初始化并查集**:
   - 初始时，每个字符串都是独立的集合。
2. **查找相似字符串对**:
   - 遍历每一对字符串，通过比较它们的字符差异，判断是否可以合并。如果差异为0或2，则认为它们是相似的。
3. **合并操作**:
   - 如果两个字符串相似，则将它们所在的集合合并。
4. **返回结果**:
   - 最终，通过并查集算法，得到所有相似字符串组成的独立集合数量。

------

这种基于并查集的方法非常高效地解决了字符串相似性的分组问题。