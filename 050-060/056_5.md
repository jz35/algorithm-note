# 第56课：并查集（上）

### 题目描述

给定一个由 `'1'`（陆地）和 `'0'`（水）组成的二维网格，计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。你可以假设该网格的四条边均被水包围。

**测试链接**: [岛屿数量 - LeetCode](https://leetcode.cn/problems/number-of-islands/)

### 输入输出描述

**输入:**

- 一个二维字符数组 `board`，其中每个字符是 `'1'`（陆地）或 `'0'`（水）。`board[i][j]` 表示网格中第 `i` 行、第 `j` 列的格子。
- 网格的行数 `n` 和列数 `m` 都小于等于 300。

**输出:**

- 返回网格中岛屿的数量。

### 算法知识

1. 并查集（Union-Find）:
   - 并查集是一种高效的数据结构，用于处理集合的合并和查询操作。在本题中，可以使用并查集来跟踪岛屿的连接关系。
   - 通过对相邻的陆地块进行合并操作，可以将每个岛屿视为一个集合。
2. 路径压缩与按秩合并:
   - 在并查集的实现中，路径压缩用于优化查找操作，按秩合并则优化合并操作，从而提高效率。

### 代码实现

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size(); // 行数
        int m = grid[0].size(); // 列数
        build(n, m, grid); // 初始化并查集
        // 遍历网格，检查相邻的陆地并合并
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == '1') { // 只处理陆地
                    if (j > 0 && grid[i][j - 1] == '1') { // 左边的陆地
                        unionSet(i, j, i, j - 1);
                    }
                    if (i > 0 && grid[i - 1][j] == '1') { // 上方的陆地
                        unionSet(i, j, i - 1, j);
                    }
                }
            }
        }
        return sets; // 返回岛屿数量
    }

private:
    int MAXSIZE = 100001; // 并查集数组最大大小
    vector<int> father; // 父节点数组
    int cols; // 列数
    int sets; // 岛屿数量

    // 初始化并查集
    void build(int n, int m, vector<vector<char>>& grid) {
        cols = m;
        sets = 0;
        father.resize(n * m); // 初始化并查集数组的大小
        for (int a = 0; a < n; a++) {
            for (int b = 0; b < m; b++) {
                if (grid[a][b] == '1') { // 遇到陆地
                    int index = getIndex(a, b);
                    father[index] = index; // 初始化父节点为自己
                    sets++; // 新岛屿增加
                }
            }
        }
    }

    // 计算二维数组的线性索引
    int getIndex(int a, int b) {
        return a * cols + b;
    }

    // 查找根节点（路径压缩）
    int find(int i) {
        if (i != father[i]) {
            father[i] = find(father[i]); // 路径压缩
        }
        return father[i];
    }

    // 合并两个集合
    void unionSet(int a, int b, int c, int d) {
        int fx = find(getIndex(a, b)); // 查找a,b的位置所在集合的根
        int fy = find(getIndex(c, d)); // 查找c,d的位置所在集合的根
        if (fx != fy) { // 如果两个集合不相同
            father[fx] = fy; // 合并两个集合
            sets--; // 岛屿数量减1
        }
    }
};
```

### 代码解释

1. **numIslands**:
   - 遍历网格中的每个陆地单元。如果该单元是陆地，并且相邻单元也是陆地，则将它们合并为一个岛屿。
   - 最后返回岛屿的总数量。
2. **build**:
   - 初始化并查集数组，将每个陆地单元作为一个独立的集合，统计岛屿数量。
3. **getIndex**:
   - 将二维坐标 `(a, b)` 转换为一维索引，用于并查集操作。
4. **find**:
   - 查找并返回元素的根节点，同时执行路径压缩，优化查询操作。
5. **unionSet**:
   - 将两个岛屿（集合）合并，并减少岛屿的数量。

### 复杂度分析

- **时间复杂度**:
  - 初始化并查集时需要遍历每个元素，时间复杂度为 `O(n * m)`，其中 `n` 和 `m` 分别是网格的行数和列数。
  - 对每对相邻的陆地进行合并操作时，时间复杂度为 `O(n * m)`。
  - 因此，整体时间复杂度为 `O(n * m)`，其中 `n` 和 `m` 是网格的维度。
- **空间复杂度**:
  - 使用并查集数组和其他辅助变量，空间复杂度为 `O(n * m)`，用于存储每个网格位置的并查集信息。

### 过程分析

1. **初始化并查集**:
   - 为每个陆地单元分配一个独立的集合，并统计岛屿数量。
2. **查找相邻的陆地**:
   - 检查当前单元的相邻单元，如果相邻单元是陆地且尚未合并，则将它们合并为一个岛屿。
3. **合并操作**:
   - 合并两个相邻的陆地单元，减小岛屿的数量。
4. **返回结果**:
   - 最终，返回所有岛屿的数量。

------

此解法利用并查集高效地处理了岛屿的合并与查找问题，适合处理大规模的网格。