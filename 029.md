# **排序算法总结**

#### **1. 排序算法的稳定性**

- **定义**：排序算法的稳定性是指，在排序后，具有相同值的元素，其相对次序保持不变。
- **适用场景**：对非基础类型对象排序时，稳定性有助于保留原始的相对顺序。
- **备注**：对基础类型对象来说，稳定性通常无意义。

------

#### **2. 常见排序算法的时间、空间复杂度与稳定性**

| 排序算法     | 时间复杂度           | 空间复杂度       | 稳定性 |
| ------------ | -------------------- | ---------------- | ------ |
| **选择排序** | O(N2)O(N^2)          | O(1)O(1)         | 无     |
| **冒泡排序** | O(N2)O(N^2)          | O(1)O(1)         | 有     |
| **插入排序** | O(N2)O(N^2)          | O(1)O(1)         | 有     |
| **归并排序** | O(Nlog⁡N)O(N \log N)  | O(N)O(N)         | 有     |
| **快速排序** | O(Nlog⁡N)O(N \log N)* | O(log⁡N)O(\log N) | 无     |
| **堆排序**   | O(Nlog⁡N)O(N \log N)  | O(1)O(1)         | 无     |
| **计数排序** | O(N)O(N)             | O(M)O(M)         | 有     |
| **基数排序** | O(N)O(N)             | O(M)O(M)         | 有     |

> *随机快速排序的复杂度是基于概率期望计算的，最差复杂度计算意义不大。

------

#### **3. 算法特性及选择指南**

1. **插入排序**：
   - 数据量非常小的情况下高效。
   - 时间复杂度为 O(N2)O(N^2)，但实现简单。
2. **随机快速排序**：
   - 性能优异，且实现简单。
   - 空间复杂度为 O(log⁡N)O(\log N)。
   - 不稳定，但可以选择不同划分策略优化。
3. **归并排序**：
   - 稳定性优秀。
   - 时间复杂度为 O(Nlog⁡N)O(N \log N)，但空间复杂度较高 (O(N)O(N))。
4. **堆排序**：
   - 不依赖额外空间，空间复杂度为 O(1)O(1)。
   - 不稳定，但性能优异。
5. **基数排序与计数排序**：
   - 时间复杂度为 O(N)O(N)，对特定场景非常高效。
   - 空间复杂度较高，适合范围固定的整数数据。

------

#### **4. 其他排序算法**

- TimSort

  ：

  - 实际应用中效率高，但空间复杂度依然是 O(N)O(N)。
  - 在算法面试和比赛中使用较少。

- 希尔排序 (ShellSort)

  ：

  - 基于插入排序的步长优化版本。
  - 不常用于面试，但值得研究。

------

总结：选择排序算法时，需要根据具体场景和需求（如数据规模、是否要求稳定性、空间复杂度限制）综合考量。例如：

- 数据量小：选择插入排序。
- 不在乎稳定性，要求高性能：选择快速排序或堆排序。
- 稳定性重要：选择归并排序。

