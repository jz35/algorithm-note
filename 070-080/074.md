# 第74课：分组背包、完全背包

## 一、前置知识
- **二维动态规划及其空间压缩技巧**：掌握二维动态规划的基本思想和实现方法，以及如何通过空间压缩技巧降低空间复杂度。这是理解和实现背包问题动态规划解法的基础。
- **01背包、有依赖的背包**：熟悉01背包和有依赖的背包问题的解法，理解动态规划在解决背包问题中的应用。

## 二、分组背包问题
### 问题描述
给定一个正数`m`表示背包的容量，有`n`个货物可供挑选。每个货物有自己的体积（容量消耗）、价值（获得收益）、组号（分组）。同一个组的物品只能挑选1件，所有挑选物品的体积总和不能超过背包容量。返回最大的价值。

### 解法
- **动态规划解法**
  - 定义`dp[j]`表示背包容量为`j`时的最大价值。
  - 对于每个组`g`，遍历组内的物品`i`，更新`dp[j]`：`dp[j] = max(dp[j], dp[j - costs[i]] + values[i])`，其中`costs[i]`是物品的体积，`values[i]`是物品的价值。
  - 初始化：`dp[0] = 0`，其余`dp[j] = -∞`。
  - 遍历顺序：先遍历组，再遍历组内的物品；对于每个物品，遍历背包容量（从大到小）。
  - 时间复杂度为O(n * m)，额外空间复杂度为O(m)。

## 三、完全背包问题
### 问题描述
给定一个正数`t`表示背包的容量，有`m`种货物，每种货物可以选择任意个。每种货物都有体积`costs[i]`和价值`values[i]`。返回在不超过总容量的情况下，怎么挑选货物能达到价值最大，返回最大的价值。

### 解法
- **动态规划解法**
  - 定义`dp[j]`表示背包容量为`j`时的最大价值。
  - 对于每种货物`i`，更新`dp[j]`：`dp[j] = max(dp[j], dp[j - k * costs[i]] + k * values[i])`，其中`k`是货物的数量，`costs[i]`是货物的体积，`values[i]`是货物的价值。
  - 初始化：`dp[0] = 0`，其余`dp[j] = -∞`。
  - 遍历顺序：先遍历货物，再遍历背包容量（从小到大）。
  - 时间复杂度为O(n * t)，额外空间复杂度为O(t)。

## 四、题目分析与解法
### 题目1：分组背包（模版）
- **问题描述**：给定背包容量`m`和`n`个货物，每个货物有体积、价值和组号，返回最大价值。
- **解法**：直接应用分组背包的动态规划解法。

### 题目2：从栈中取出K个硬币的最大面值和
- **问题描述**：有`n`个栈，每个栈有若干个硬币，每次可以从任意栈的顶部取出1个硬币，返回取出`k`个硬币的最大面值和。
- **解法**：将问题转化为分组背包问题，其中每个栈是一个组，组内的硬币是物品。使用分组背包的动态规划解法求解。

### 题目3：完全背包（模版）
- **问题描述**：给定背包容量`t`和`m`种货物，每种货物可以选择任意个，返回最大价值。
- **解法**：直接应用完全背包的动态规划解法。

### 题目4：正则表达式匹配
- **问题描述**：给定字符串`s`和模式字符串`p`，支持`.`和`*`，返回`p`是否能匹配`s`。
- **解法**：使用动态规划，定义`dp[i][j]`表示`s`的前`i`个字符是否能被`p`的前`j`个字符匹配。状态转移方程根据`p[j - 1]`是否为`*`进行分类讨论。

### 题目5：通配符匹配
- **问题描述**：给定字符串`s`和模式字符串`p`，支持`?`和`*`，返回`p`是否能匹配`s`。
- **解法**：与正则表达式匹配类似，但边界条件有所不同。使用动态规划，定义`dp[i][j]`表示`s`的前`i`个字符是否能被`p`的前`j`个字符匹配。状态转移方程根据`p[j - 1]`是否为`*`或`?`进行分类讨论。

### 题目6：购买足量干草的最小花费
- **问题描述**：有`n`个提供干草的公司，每个公司有成本`cost[i]`和干草数量`val[i]`，返回购买至少`h`数量干草的最小花费。
- **解法**：将问题转化为完全背包问题，其中每种货物的体积为`cost[i]`，价值为`val[i]`。使用完全背包的动态规划解法求解。

## 五、总结
- 本节课主要讲解了分组背包和完全背包问题的解法，重点在于掌握动态规划的思想和实现方法。
- 通过这些题目的学习，可以深入理解动态规划在解决背包问题中的应用，以及如何处理分组和无限选择的情况。
- 在学习过程中，需要注意理解每个问题的解题思路和状态转移方程，以及如何将复杂问题转化为已知的简单问题来求解。
