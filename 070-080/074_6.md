# 第74课：分组背包、完全背包

### 题目：购买足量干草的最小花费

**题目描述**： 有 `n` 个提供干草的公司，每个公司有两个信息：

- `cost[i]`：购买该公司产品一次需要的花费
- `val[i]`：购买该公司产品一次所获得的干草数量

每个公司的产品可以购买任意次。

你需要至少购买 `h` 数量的干草，求最少需要花多少钱。

**输入描述**：

- 第一行包含两个整数 `n` 和 `h`，分别表示公司数量和需要购买的干草数量。
- 接下来 `n` 行，每行包含两个整数 `val[i]` 和 `cost[i]`，分别表示第 `i` 个公司提供的干草数量和价格。

**输出描述**：

- 输出最少需要花的钱。如果无法满足需求，则输出 `-1`。

**示例**：

输入：

```
3 10
6 10
4 6
7 12
```

输出：

```
20
```

**题解**： 这是一个典型的动态规划问题，和背包问题类似。我们用动态规划数组 `dp[i]` 表示购买 `i` 个干草所需要的最小花费。状态转移方程的核心是：我们可以选择某个公司购买干草，更新状态为当前干草数量的花费。最终的答案是从 `dp[h]` 到 `dp[m]` 中的最小值。

#### 动态规划解决方案：

1. **定义状态**：

   - `dp[i]`：购买 `i` 个干草所需要的最小花费。

2. **状态转移**：

   - 对于每个公司 

     ```
     i
     ```

     ，如果我们购买了 

     ```
     val[i]
     ```

      数量的干草，那么：

     ```
     dp[j] = min(dp[j], dp[j - val[i]] + cost[i]);
     ```

     其中，

     ```
     j
     ```

      是当前的干草数量，

     ```
     val[i]
     ```

      是当前公司提供的干草数量，

     ```
     cost[i]
     ```

      是该公司提供干草的价格。

3. **初始化**：

   - `dp[0] = 0`，表示购买 0 个干草的花费是 0。
   - 其他状态初始化为无穷大，表示尚未计算。

4. **最终结果**：

   - 遍历 `dp[h]` 到 `dp[m]`，找出最小的花费即为答案。

#### 代码实现（C++）：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <climits>
using namespace std;

const int MAXN = 101;
const int MAXM = 55001;

int val[MAXN], cost[MAXN], dp[MAXM];

int n, h, maxv, m;

int compute2() {
    // 初始化 dp 数组，默认是无穷大
    fill(dp, dp + m + 1, INT_MAX);
    dp[0] = 0;  // 购买 0 个干草的花费是 0

    // 动态规划更新
    for (int i = 1; i <= n; i++) {
        for (int j = val[i]; j <= m; j++) {
            if (dp[j - val[i]] != INT_MAX) {
                dp[j] = min(dp[j], dp[j - val[i]] + cost[i]);
            }
        }
    }

    // 求解最小花费，至少需要购买 h 个干草
    int ans = INT_MAX;
    for (int j = h; j <= m; j++) {
        ans = min(ans, dp[j]);
    }
    return ans;
}

int main() {
    // 快速输入输出
    scanf("%d %d", &n, &h);
    
    maxv = 0;
    for (int i = 1; i <= n; i++) {
        scanf("%d %d", &val[i], &cost[i]);
        maxv = max(maxv, val[i]);
    }
    
    m = h + maxv;  // 需要考虑最多可能的干草数量
    printf("%d\n", compute2());
    
    return 0;
}
```

### 时间复杂度：

- **时间复杂度**：`O(n * m)`，其中 `n` 是公司数量，`m` 是最多干草数量（`h + maxv`）。
- **空间复杂度**：`O(m)`，用于存储 `dp` 数组。

### 思路分析：

1. **背包问题**：这道题是典型的背包问题，只不过每个公司可以购买任意次数，因此可以重复选择。
2. **空间优化**：使用一维数组 `dp` 代替二维数组，通过从后向前更新来避免状态冲突。
3. **最小花费计算**：我们最终只关心 `h` 到 `m` 的最小花费。