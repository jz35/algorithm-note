# 第73课：01背包、有依赖的背包

------

### 题目描述

有一堆石头，用整数数组 `stones` 表示，其中 `stones[i]` 表示第 `i` 块石头的重量。每一回合，从中选出任意两块石头，然后将它们一起粉碎。

假设石头的重量分别为 `x` 和 `y`，且 `x <= y`，那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y - x`。

最后，最多只会剩下一块石头，返回此石头最小的可能重量。如果没有石头剩下，就返回 0。

### 输入

- 一个整数数组 `stones`，表示石头的重量，`stones[i]` 是第 `i` 块石头的重量。

### 输出

- 返回最后剩下的石头的最小可能重量。如果没有石头剩下，返回 0。

### 示例

#### 示例 1

**输入：**

```cpp
stones = [2, 7, 4, 1, 8, 1]
```

**输出：**

```cpp
1
```

**解释：**

- 从数组中选取 7 和 8 粉碎，剩下 [2, 4, 1, 1, 1]；
- 从数组中选取 4 和 2 粉碎，剩下 [1, 1, 1, 2]；
- 从数组中选取 2 和 1 粉碎，剩下 [1, 1, 1]；
- 从数组中选取 1 和 1 粉碎，剩下 [1]。

最终返回 1。

#### 示例 2

**输入：**

```cpp
stones = [31, 26, 33, 21, 40]
```

**输出：**

```cpp
5
```

**解释：**

通过适当选择并粉碎石头，最终可以剩下 5。

### 提示

- 1 <= `stones.length` <= 30
- 1 <= `stones[i]` <= 1000

### 算法知识

本题可以使用 **动态规划** 来解决，类似于 **01 背包问题**，目标是找到一个子集，使得其和最接近 `sum / 2`，从而能够尽量减少最后剩下的石头重量。

#### 动态规划思路：

1. 计算所有石头的总和 `sum`。
2. 使用动态规划，定义 `dp[i]` 为在不超过 `i` 的条件下，能够获得的最接近 `i` 的石头总重量。
3. 最终，我们要得到的结果是 `sum - 2 * dp[sum / 2]`，因为我们通过尽量让子集和接近 `sum / 2` 来最小化最后剩下的石头重量。

### 代码实现

```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int sum = 0;
        for (int stone : stones) {
            sum += stone;
        }
        // 找到接近 sum / 2 的子集和
        int nearSum = near(stones, sum / 2);
        return sum - nearSum - nearSum;
    }

private:
    // 01背包问题，返回最接近t的累加和
    int near(vector<int>& nums, int t) {
        vector<int> dp(t + 1, 0);
        for (int num : nums) {
            for (int j = t; j >= num; --j) {
                dp[j] = max(dp[j], dp[j - num] + num);
            }
        }
        return dp[t];
    }
};
```

### 复杂度分析

- 时间复杂度：`O(n * sum)`，其中 `n` 为石头的数量，`sum` 为所有石头重量的总和。动态规划的状态转移需要遍历每个石头，并更新所有子问题的解。
- 空间复杂度：`O(sum)`，我们使用了一个一维数组 `dp` 来存储子集的和。

------

这就是本题的整理版本，包括题目描述、输入输出格式、算法思路、代码实现和复杂度分析。