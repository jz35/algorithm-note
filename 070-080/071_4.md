# 第71课：子数组最大累加和问题与扩展-下

------

## 题目描述

给定一个整数数组 `nums` 和一个整数 `k`，请你找到三个长度为 `k` 、互不重叠、且全部数字和（3 * k 项）最大的子数组，并返回这三个子数组的起始位置。最终结果返回一个包含三个整数的数组，表示三个子数组的起始位置。

如果有多个结果，返回字典序最小的一个。

### 函数签名

```cpp
class Solution {
public:
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k);
};
```

### 输入

- `nums`：一个长度为 `n` 的整数数组 `nums` （`1 <= n <= 2000`，`0 <= nums[i] <= 1000`）。
- `k`：一个正整数，表示每个子数组的长度（`1 <= k <= n / 3`）。

### 输出

- 返回一个数组，包含三个子数组的起始位置。

### 示例

#### 示例 1

**输入**:

```cpp
nums = [1,2,1,2,6,7,5,1], k = 2
```

**输出**:

```cpp
[0, 3, 5]
```

**解释**:

- 第一个子数组 `[1, 2]`，起始位置为 0。
- 第二个子数组 `[1, 2]`，起始位置为 3。
- 第三个子数组 `[6, 7]`，起始位置为 5。

这三个子数组的和是 `1 + 2 + 1 + 2 + 6 + 7 = 19`，是最大的和。

#### 示例 2

**输入**:

```cpp
nums = [1,2,1,2,1,2,1,2,1], k = 2
```

**输出**:

```cpp
[0, 2, 4]
```

**解释**:

- 第一个子数组 `[1, 2]`，起始位置为 0。
- 第二个子数组 `[1, 2]`，起始位置为 2。
- 第三个子数组 `[1, 2]`，起始位置为 4。

这三个子数组的和是 `1 + 2 + 1 + 2 + 1 + 2 = 9`，是最大的和。

### 提示

- `1 <= n <= 2000`
- `1 <= k <= n / 3`

------

## 解题思路

1. **`sums` 数组**：
   - 用来存储从 `i` 开始、长度为 `k` 的子数组的和。
   - 通过滑动窗口的方式，计算每个子数组的和。
2. **`prefix` 数组**：
   - `prefix[i]` 表示在 `0` 到 `i` 范围内，拥有最大累加和的子数组的起始位置。
   - 通过比较当前子数组的和与之前的最大子数组和，决定是否更新 `prefix[i]`。
3. **`suffix` 数组**：
   - `suffix[i]` 表示在 `i` 到 `n-1` 范围内，拥有最大累加和的子数组的起始位置。
   - 同样通过比较当前子数组的和与后续的最大子数组和，决定是否更新 `suffix[i]`。
4. **计算最终的最大和**：
   - 遍历所有可能的中间子数组（从 `k` 到 `2k-1`），对于每个中间子数组 `i` 和 `j`，通过 `prefix[i-1]` 获取左侧子数组的起始位置，`suffix[j+1]` 获取右侧子数组的起始位置，计算这三段子数组的总和。
   - 更新最大总和及其对应的起始位置。
5. **返回结果**：
   - 最终返回三段子数组的起始位置，分别对应 `a`、`b`、`c`。

------

## 代码实现（C++）

```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
        int n = nums.size();
        
        // sums[i] : 以i开头并且长度为k的子数组的累加和
        vector<int> sums(n, 0); // 初始化sums数组为0
        for (int l = 0, r = 0, sum = 0; r < n; r++) {
            // 计算窗口的总和，窗口大小为k
            sum += nums[r];
            if (r - l + 1 == k) {
                sums[l] = sum;  // 记录当前窗口的和
                sum -= nums[l]; // 滑动窗口，移除左边的元素
                l++;            // 左边界右移
            }
        }
        
        // prefix[i] : 在0~i范围内，拥有最大累加和的子数组的起始位置
        vector<int> prefix(n, 0);
        for (int l = 1, r = k; r < n; l++, r++) {
            if (sums[l] > sums[prefix[r - 1]]) {
                // 如果sums[l]比当前区间内最大累加和大，更新prefix
                prefix[r] = l;
            } else {
                // 否则，继承之前的最大累加和起始位置
                prefix[r] = prefix[r - 1];
            }
        }
        
        // suffix[i] : 在i~n-1范围内，拥有最大累加和的子数组的起始位置
        vector<int> suffix(n, 0);
        suffix[n - k] = n - k;  // 最后一个长度为k的子数组的起始位置
        for (int l = n - k - 1; l >= 0; l--) {
            if (sums[l] >= sums[suffix[l + 1]]) {
                // 如果sums[l]比当前区间内最大累加和大或相等，更新suffix
                suffix[l] = l;
            } else {
                // 否则，继承之前的最大累加和起始位置
                suffix[l] = suffix[l + 1];
            }
        }

        // 记录结果
        int a = 0, b = 0, c = 0, maxSum = 0;
        
        // 遍历中间子数组的起始位置 i 和 j，计算总和并更新最大值
        for (int i = k, j = 2 * k - 1; j < n - k; i++, j++) {
            int p = prefix[i - 1];  // 左侧子数组的起始位置
            int s = suffix[j + 1];  // 右侧子数组的起始位置
            int sum = sums[p] + sums[i] + sums[s];  // 当前三段子数组的总和

            // 如果当前的三段子数组总和更大，更新结果
            if (sum > maxSum) {
                maxSum = sum;
                a = p;
                b = i;
                c = s;
            }
        }

        // 返回结果，包含三个子数组的起始位置
        return {a, b, c};
    }
};
```

### 时间复杂度：

- **时间复杂度**：`O(n)`，由于我们只做了三次线性遍历：一次计算 `sums`，一次计算 `prefix`，一次计算 `suffix`，以及一次计算最终结果的遍历。
- **空间复杂度**：`O(n)`，使用了三个数组 `sums`、`prefix` 和 `suffix`，每个大小为 `n`。

### 提示：

- `1 <= n <= 2000`
- `1 <= k <= n / 3`